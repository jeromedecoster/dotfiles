#!/bin/bash
[[ ! "$OSTYPE" =~ ^darwin ]] && echo "Aborted: this install script is only for OS X" && exit 1

# write colored putput
function green() { [[ $# -eq 1 ]] && echo -e "\033[0;32m$1\033[0m"; }
function red()   { [[ $# -eq 1 ]] && echo -e "\033[0;31m$1\033[0m"; }

# write in blue has a special behavior, will try to reduce path
# from /Users/username/.dotfiles to ~/.dotfiles
function blue()  {
    if [[ $# -eq 1 ]]; then
        if [[ ! -e "$1" ]]; then
            echo -e "\033[0;34m$1\033[0m"
        else
            # if the path is in the user folder ($HOME), reduce the output
            # message using the shortcut '~'
            # from /Users/username/.dotfiles to ~/.dotfiles
            if [[ $HOME == ${1:0:${#HOME}} ]]; then
                echo -e "\033[0;34m~${1:${#HOME}}\033[0m"
            # otherwise, simple output
            else
                echo -e "\033[0;34m$1\033[0m"
            fi
        fi
    fi
}

function ok()    { echo -e "$(green OK)"; }
function notok() { echo -e "$(red KO)"; }

# check if a folder is empty
# if yes, return 1, otherwise return 0
function empty() {
    [[ $# -ne 1 ]] && echo "Runtime error: empty require 1 argument" && exit 1
    [[ ! -d $1 ]]  && echo "Runtime error: empty require a folder path" && exit 1
    [[ $(find $1 -depth 1 2>/dev/null | grep . -c) -eq 0 ]] && echo 1 || echo 0
}

function browser() {
    local url=$1
    [[ ${url:0:4} != 'http' ]] && url="http://$url"

    # if Chrome, browse with it
    if [[ -d '/Applications/Google Chrome.app' ]]; then
        arch -i386 osascript <<EOF
            set launched to true
            if application "Google Chrome" is not running then
                set launched to false
                tell application "Google Chrome" to activate
                delay 0.5
            end if
            on curtab(pUrl)
                tell application "Google Chrome" to set URL of active tab of front window to pUrl
            end curtab
            tell application "Google Chrome"
                if launched is false then
                    curtab("$url") of me
                else
                    if (count of properties of windows) is 0 then
                        make new window
                        curtab("$url") of me
                    else
                        if URL of active tab of front window is "chrome://newtab/" then
                            curtab("$url") of me
                        else
                            tell front window to make new tab
                            curtab("$url") of me
                        end if
                    end if
                end if
            end tell
EOF
    # if Firefox, browse with it
    elif [[ -d '/Applications/Firefox.app' ]]; then
        open -a Firefox.app $url
    # otherwise fallback to Safari
    elif [[ -d '/Applications/Safari.app' ]]; then
        open -a Safari.app $url
    fi
}

# check Git
echo -n "Check $(blue git)..."
if [[ ! "$(type -p git)" ]]; then
    notok
    echo 'Aborted: Git must be installed'
    sleep 1
    browser 'http://git-scm.com/download/mac'
    exit 1
fi
ok

# check Ruby
echo -n "Check $(blue ruby)..."
if [[ ! "$(type -p ruby)" || $(ruby -e "puts RUBY_VERSION >= '1.9.3'") == 'false' ]]; then
    notok
    echo 'Aborted: Ruby must be installed. Version 1.9.3 minimum'
    sleep 1
    browser 'https://rvm.io/'
    exit 1
fi
ok


# start of the Homebrew part...

brew_path=$(type -P brew)
if [[ ! "$brew_path" ]]; then
    # homebrew is cool but doesn't have an online repository like npm or rubygem
    # so, all formula (2300+) are downloaded locally via the git repo
    # and you all history of each formula. Not really cool...
    # so the installation process is really slow
    echo "Install $(blue homebrew) (please wait, it's slow)"

    # automatic install (without asking the user keydown)
    # is only possible with the addition of 'true |'
    # true | ruby -e "$(curl -fsSL https://raw.github.com/mxcl/homebrew/go)"
    
    # personnal install
    ruby -e "$(curl -fsSL raw.github.com/jeromedecoster/dotfiles/master/osx/homebrew)"

# is really here, it's an executable?
# this test is needed after an uninstall
elif [[ -x "$brew_path" ]]; then
    echo -n "Update $(blue homebrew)..."
    # brew update: fetch the newest version of Homebrew
    # and all formulae from GitHub using git
    brew update 1>/dev/null
    if [[ $? -ne 0 ]]; then
        notok
        echo 'Failed: Homebrew update return an error'
    else
        ok
    fi

    echo -n "Upgrade $(blue homebrew)..."
    # brew upgrade: Upgrade outdated, unpinned brews
    brew upgrade 1>/dev/null
    if [[ $? -ne 0 ]]; then
        notok
        echo 'Failed: Homebrew upgrade return an error'
    else
        ok
    fi
fi

# Homebrew is installed... now install some forumlas

function install_formula() {
    if [[ ! $(brew ls -1 | grep -E "^$1$") ]]; then
        echo -n "Install $(blue $1)..."
        # redirect stdout and stderr to null, full silence
        brew install "$1" &>/dev/null
        if [[ $? -ne 0 ]]; then
            notok
            echo "Failed: $1 installation return an error"
        else
            ok
        fi
    fi
}

install_formula tree
install_formula man2html
install_formula phantomjs

# ...the end of the Homebrew part


# update existing ~/.dotfiles repositoy or clone it first the first time
if [[ -e ~/.dotfiles ]]; then
    cur=$(pwd)
    echo -n "Update $(blue ~/.dotfiles) repository..."
    cd ~/.dotfiles
    # capture error
    error=$(git pull --quiet 2>&1)
    exit_code=$?
    cd "$cur"
    if [[ $exit_code -ne 0 ]]; then
        notok
        echo $error
        echo 'Aborted: Error with git pull'
        exit 1
    fi
    ok
else
    echo -n "Install $(blue ~/.dotfiles) repository..."
    # capture error
    error=$(git clone --quiet https://github.com/jeromedecoster/dotfiles.git ~/.dotfiles 2>&1)
    if [[ $? -ne 0 ]]; then
        notok
        echo $error
        echo 'Aborted: Error with git clone'
        exit 1
    fi
    ok
fi

# create backup folder
backup=~/.dotfiles/.backup/$(date +%Y-%m-%d--%H-%M-%S)
mkdir -p "$backup"

function copy_files() {
    [[ $# -ne 3 ]] && echo "Runtime error: copy require 3 arguments" && exit 1
    if [[ ! -d "$3" || ! -d "$3" || ! -d "$3" ]]; then
        echo "Runtime error: copy require 3 valid paths" && exit 1
    fi
    local name
    for f in $1/{.*,*}; do
        name=$(basename "$f")
        # not readable, skip
        [[ ! -r "$f" ]] && continue
        # special files, skip
        [[ "$name" == '.' || "$name" == '..' || "$name" == '.DS_Store' ]] && continue
        if [[ -e $2/$name ]]; then
            mv "$2/$name" "$backup"
            cp -rp "$f" "$2"
            echo -e "Backup then overwrite $(blue $2/$name)"
        else
            cp -rp "$f" "$2"
            echo -e "Add $(blue $2/$name)"
        fi
    done
}

# copy files from ~/.dotfiles/osx/user folder to ~
# and backup already existing files to the backup folder
copy_files ~/.dotfiles/osx/user ~ $backup

# install a chrome extension. The installation process is manual (open the extension page on the chrome web store)
# even if an automatic/silent process is possible and successfully tested. Why? Because:
# - a locally installed crx will not benefit easily/automatically of the future updates
# - if you manually uninstall an extension that had been installed silently, this extension is definitly blacklisted
# http://developer.chrome.com/extensions/external_extensions.html#faq
# please note there is no safe and simple ways to unsintall an extension, you need to do it manually
function chrome_extension() {
    # abort function if chrome is not installed
    [[ ! -d '/Applications/Google Chrome.app' ]] && return
    [[ $# -ne 3 ]] && echo "Runtime error: chrome_extension require 3 arguments" && exit 1
    # argument 1, the name to be displayed
    # argument 2, the id of the extension, it also the directory name to check (if directory, it's installed)
    # argument 3, the URL to open with chrome for launch manual installation
    local name=$(blue "$1")
    echo -n -e "Check $name chrome extension..."
    if [[ ! -d ~/Library/Application\ Support/Google/Chrome/Default/Extensions/$2 ]]; then
        notok
        while true; do
            echo -e -n "Install $name? [Yn]: "
            read r
            r=$(echo "$r" | tr '[A-Z]' '[a-z]')
            case "$r" in
                y|n) break ;;
                 '') r='y' && break ;;
            esac
        done

        [[ "$r" == 'y' ]] && browser $3
    else
        ok
    fi
}

chrome_extension 'Adblock Plus'   'cfhdojbkjhnklbpkdaibdccddilifddb' \
                 'https://chrome.google.com/webstore/detail/empty-title/cfhdojbkjhnklbpkdaibdccddilifddb'
chrome_extension 'PrettyPrint'    'nipdlgebaanapcphbcidpmmmkcecpkhg' \
                 'https://chrome.google.com/webstore/detail/prettyprint/nipdlgebaanapcphbcidpmmmkcecpkhg'
chrome_extension 'JSON Formatter' 'bcjindcccaagfpapjjmafapmmgkkhgoa' \
                 'https://chrome.google.com/webstore/detail/json-formatter/bcjindcccaagfpapjjmafapmmgkkhgoa'
chrome_extension 'LiveReload'     'jnihajbhpnppcggbcgedagnkighmdlei' \
                 'https://chrome.google.com/webstore/detail/livereload/jnihajbhpnppcggbcgedagnkighmdlei'

# install a firefox extension. The installation process is manual, just like for the chrome process
# please note the unsintall is also manual
function firefox_extension() {
    # abort function if firefox is not installed
    [[ ! -d '/Applications/Firefox.app' ]] && return
    [[ $# -ne 3 ]] && echo "Runtime error: firefox_extension require 3 arguments" && exit 1
    # argument 1, the name to be displayed
    # argument 2, the xpi filename to checked inside the extensions directory (if found, it's installed)
    # argument 3, the URL to open with firefox for launch manual installation
    local name=$(blue "$1")
    echo -n -e "Check $name firefox extension..."
    local profile="$(find ~/Library/Application\ Support/Firefox/Profiles -type d -depth 1 -name '*.default')"
    if [[ ! "$profile" || ! -f "$profile/extensions/$2" ]]; then
        notok
        while true; do
            echo -e -n "Install $name? [Yn]: "
            read r
            r=$(echo "$r" | tr '[A-Z]' '[a-z]')
            case "$r" in
                y|n) break ;;
                 '') r='y' && break ;;
            esac
        done

        [[ "$r" == 'y' ]] && open -a Firefox.app $3
    else
        ok
    fi
}

firefox_extension 'Adblock Plus' '{d10d0bf8-f5b5-c8b4-a8b2-2b9879e08c5d}.xpi' \
                  'https://addons.mozilla.org/en-US/firefox/addon/adblock-plus/'

firefox_extension 'Firebug'      'firebug@software.joehewitt.com.xpi' \
                  'https://addons.mozilla.org/en-US/firefox/addon/firebug/'

# need to relaunch Firefox
firefox_extension 'Net Export'   'netexport@getfirebug.com.xpi' \
                  'https://getfirebug.com/releases/netexport/'

# need to relaunch Firefox
firefox_extension 'DownThemAll'  '{DDC359D1-844A-42a7-9AA1-88A850A938A8}.xpi' \
                  'https://addons.mozilla.org/en-US/firefox/addon/downthemall/'

firefox_extension 'LiveReload'   'livereload@livereload.com.xpi' \
                  'http://help.livereload.com/kb/general-use/browser-extensions'

# removes some folders if stayed empty
if [[ $(empty $backup) -eq 1 ]]; then
    echo -e "Delete empty folder $(blue "$backup")" && rm -d $backup
fi
if [[ $(empty ~/.dotfiles/.backup) -eq 1 ]]; then
    echo -e "Delete empty folder $(blue "~/.dotfiles/.backup")" && rm -d ~/.dotfiles/.backup
fi
