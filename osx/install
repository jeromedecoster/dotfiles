#!/bin/bash
[[ ! "$OSTYPE" =~ ^darwin ]] && echo "Aborted: this install script is only for OS X" && exit 1

#
# Write colored output
#
green() {
  echo -e "\033[0;32m$1\033[0m"
}
red() {
  echo -e "\033[0;31m$1\033[0m"
}
blue() {
  echo -e "\033[0;34m$1\033[0m"
}
yellow() {
  echo -e "\033[0;33m$1\033[0m"
}
ok() {
  echo `green OK`
}
notok() {
  echo `red KO`
}

#
# Write a message with 5 seconds delay info
#
message_delay() {
  for i in {5..0}; do
    if [[ $i -gt 0 ]]; then
      echo "$1 `yellow "   [in $i sec]"`"
      sleep 1
      # erase_line
      printf "\033[1A\033[2K"
    else
      echo $1
    fi
  done
}

#
# Remove a path from the $PATH
# It does not update the $PATH but just echo a ready to set one
#
path_remove() {
  # convert path to an array
  tmp=$IFS
  IFS=:
  t=($PATH)
  # remove paths found from the array
  unset IFS
  t=(${t[@]%%$1})
  # echo the result, an array joined with ':'
  IFS=:
  echo "${t[*]}"
  IFS=$tmp
}

#
# Echo the index of the first argument inside the $PATH
# Do nothing if not found
#
path_index() {
  # convert path to an array
  tmp=$IFS
  IFS=:
  t=($PATH)
  IFS=$tmp
  # loop and echo index if path found
  local i=0
  for p in ${t[@]}; do
    [[ $p = $1 ]] && echo $i && return
    i=$((i + 1))
  done
}

#
# Append the first argument to the $PATH
# Do nothing if not a valid directory or alreay in $PATH
#
path_append() {
  # security test before append
  [[ ! -d $1 ]] && return
  # not already in $PATH
  if [[ -z `path_index $1` ]]; then
    PATH=$1:$PATH
    export PATH
  fi
}

#
# By default /usr/local/bin is placed after /usr/bin in the $PATH
# This function updates the $PATH with /usr/local/bin placed just before /usr/bin
# It's a temporary path, only valid in this install session
#
path_local_first() {
  local bin=`path_index /usr/bin`
  # /usr/bin is found before /usr/local/bin
  if [[ $bin -lt `path_index /usr/local/bin` ]]; then
    # remove /usr/local/bin from the path and convert path to an array
    tmp=$IFS
    IFS=:
    t=(`path_remove /usr/local/bin`)
    # replace in the array /usr/bin by /usr/local/bin:/usr/bin
    t[$bin]='/usr/local/bin:/usr/bin'
    # echo the result, an array joined with ':'
    IFS=:
    PATH=`echo "${t[*]}"`
    export PATH
    IFS=$tmp
  fi
}

#
# Try to reduce the path from /Users/username/.dotfiles to ~/.dotfiles
# This is pure string operation, nothing to do with $PATH
#
reduce_path() {
  # if the path is in the user directory ($HOME), reduce it using the shortcut '~'
  if [[ $HOME == ${1:0:${#HOME}} ]]; then
    echo ~${1:${#HOME}}
  # otherwise return the argument
  else
    echo $1
  fi
}

#
# Check if I am the owner of a file or a directory
# The test can include all sub files and sub directories if the second argument is -R
# Return nothing if something failed
# Return 1 if I am the owner of file(s)/director(y|ies), otherwise return 0
#
check_owner() {
  # security test before check
  [[ -n $2 && $2 != '-R' ]] && echo `red 'runtime: check_owner wrong second argument'` && exit 1

  # abort if the target does not exist
  [[ ! -e "$1" ]] && return

  # recursive test
  if [[ $2 = '-R' ]]; then

    # abort if the target is not a directory
    [[ ! -d "$1" ]] && return

    local who=`whoami | xargs id -u`

    # return the count of files and directories from the directory "$1" where the owner is not me
    # the result include the "$1" directory
    # the result exclude some crap files and directories
    local count=`find -E "$1" ! -name .DS_Store \
                              ! -name desktop.ini \
                              ! -name Thumbs.db \
                              ! -regex ".*/\.DocumentRevisions-V100/*.*" \
                              ! -regex ".*/\.fseventsd/*.*" \
                              ! -regex ".*/\.TemporaryItems/*.*" \
                              ! -regex ".*/\.Trashes/*.*" \
                              ! -regex ".*/\.Spotlight-V100/*.*" \
                              ! -regex ".*/\.(git|svn)/*.*" -exec stat -f %u '{}' \; -print \
                  | egrep "^[[:digit:]]+$" \
                  | grep -vc $who`

    [[ $count -eq 0 ]] && echo 1 || echo 0

  # not a recursive test
  else
    [[ `stat -f %u "$1"` = `id -u` ]] && echo 1 || echo 0
  fi
}

#
# Check if I am the owner of a file or a directory
# The test can also can include all sub files and sub directories if the third argument is -R
# If not, prompt to chown the file or directory
# All the content will be recursivly chowned if the third argument is -R
# Echo check and result if the first argument is -v
# The fourth argument is an additional echo
#
check_chown() {
  # some security tests before check
  [[ -n $1 && $1 != '-v' ]] && echo `red 'runtime: check_chown wrong first argument'` && exit 1
  [[ -n $3 && $3 != '-R' ]] && echo `red 'runtime: check_chown wrong third argument'` && exit 1

  local path=`reduce_path "$2"`

  # echo check if verbose mode
  [[ $1 = '-v' ]] && echo -n "check `blue "$path"` owner..."

  local check=`check_owner "$2" $3`
  # echo "check:$check:"
  # you are not the owner of file(s) or director(y|ies)
  if [[ -n $check && $check -eq 0 ]]; then

    # echo result if verbose mode
    [[ $1 = '-v' ]] && notok

    if [[ $3 = '-R' ]]; then
      echo "you are not the owner of the directory `blue "$path"` or all his content"
    else
      local kind='file'
      [[ -d "$2" ]] && kind='directory'
      echo "you are not the owner of the $word `blue "$path"`"
    fi

    [[ -n $4 ]] && echo "$4"

    while true; do
      echo -n "do you want to `blue 'sudo chown'` it? [Yn]: "
      read r
      r=$(echo "$r" | tr '[A-Z]' '[a-z]')
      case "$r" in
        y|n) break ;;
         '') r='y' && break ;;
      esac
    done
    [[ "$r" == 'y' ]] && sudo chown $3 `whoami` "$2"

  # you are he owner of file(s) or director(y|ies)
  # or the file or directory does not exist
  else
    # echo result if verbose mode
    [[ $1 = '-v' ]] && ok
  fi
}

check_homebrew() {

  # inner functions
  function install() {
    # prompt to chown /usr/local if I am not the owner
    check_chown -v /usr/local

    # abort after a new check
    [[ `check_owner /usr/local` -ne 1 ]] && echo "abort: you must be the owner of `red /usr/local`" && exit 1

    message_delay "install minimal `blue homebrew` in `blue /usr/local/homebrew`"

    # clone homebrew with the available git
    local tmp
    [[ `type -p git` ]] && tmp=git || tmp=/Developer/usr/bin/git

    # install minimal homebrew (without all repository history)
    eval "$tmp clone --depth 1 https://github.com/mxcl/homebrew.git /usr/local/homebrew"

    if [[ $? -ne 0 ]]; then
      echo 'abort: Error with git clone'
      exit 1
    fi

    # temp path, only valid in this install session
    path_append /usr/local/homebrew/bin

    echo -n "check `blue homebrew` install..."
    # check if brew is now in the path
    if [[ -z `type -p brew` ]]; then
      notok
      echo "abort: the `red "scripted install of homebrew has failed"`. Please do it manually"
      exit 1
    else
      ok
    fi
  }
  function update() {
    echo -n "update `blue homebrew`..."
    # brew update: fetch the newest version of Homebrew and all formulae from GitHub using git
    brew update 1>/dev/null
    if [[ $? -ne 0 ]]; then
      notok
      echo "fail: `red "brew update"` return an error"
    else
      ok
    fi
  }

  echo -n "check `blue homebrew`..."
  # homebrew not detected, install it
  if [[ -z `type -p brew` ]]; then
    # brew not in the path and also not on the machine
    if [[ ! -x /usr/local/homebrew/bin/brew ]]; then
      notok
      install
    # it's only a path problem
    else
      path_append /usr/local/homebrew/bin
      ok
      # update
    fi

  # homebrew detected, update the git source
  else
    ok
    update
  fi

  unset -f install
  unset -f update
}

#
# Check if a directory is empty, the test includes the hidden files. Return 1 if empty, otherwise return nothing
#
empty_directory() {
  [[ `find $1 -depth 1 2>/dev/null | grep . -c` -eq 0 ]] && echo 1
}

#
# Open an url with chrome if installed, otherwise with firefox, otherwise with safari
#
browser() {
  local url=$1
  [[ ${url:0:4} != 'http' ]] && url="http://$url"

  # if Chrome, browse with it
  if [[ -d '/Applications/Google Chrome.app' ]]; then
    local cmd
    arch -i386 pwd &>/dev/null
    [[ $? -eq 0 ]] && cmd="arch -i386 osascript" || cmd="osascript"
    eval "$cmd" <<EOF
      set launched to true
      if application "Google Chrome" is not running then
        set launched to false
        tell application "Google Chrome" to activate
        delay 0.5
      end if
      on curtab(pUrl)
        tell application "Google Chrome" to set URL of active tab of front window to pUrl
      end curtab
      tell application "Google Chrome"
        if launched is false then
          curtab("$url") of me
        else
          if (count of properties of windows) is 0 then
            make new window
            curtab("$url") of me
          else
            if URL of active tab of front window is "chrome://newtab/" then
              curtab("$url") of me
            else
              tell front window to make new tab
              curtab("$url") of me
            end if
          end if
        end if
      end tell
EOF
  # if Firefox, browse with it
  elif [[ -d '/Applications/Firefox.app' ]]; then
    open -a Firefox.app $url
  # otherwise fallback to Safari
  elif [[ -d '/Applications/Safari.app' ]]; then
    open -a Safari.app $url
  fi
}

#
# Sets the frontmost opened terminal window as the foreground window on screen
# and sets the other terminal windows to the background. It's a dirty hack because
# activate set all the windows of an application to the foreground
#
terminal_frontmost() {
  local cmd
  arch -i386 pwd &>/dev/null
  [[ $? -eq 0 ]] && cmd="arch -i386 osascript" || cmd="osascript"
  eval "$cmd" <<EOF
  tell application "Terminal"
    activate
    set skip to true
    repeat with e in windows
      try
        if not skip then
          set frontmost of e to false
        end if
        set skip to false
      end try
    end repeat
    log ""
  end tell
EOF
}

#
# Copy files from a folder to another folder and automatically backup all already existing files
# The function invokes 'create_backup' who creates backup folder and defines the variable $backup
#
copy_files() {
  # some security tests before copy
  [[ $# -ne 2 ]] && echo `red 'runtime: copy_files require 2 arguments'` && exit 1
  [[ ! -d "$1" || ! -d "$2" ]] && echo `red 'runtime: copy_files require 2 valid paths'` && exit 1

  # create backup folder and define $backup
  create_backup

  local name path
  for f in $1/{.*,*}; do
    name=`basename "$f"`
    # not readable, skip
    [[ ! -r "$f" ]] && continue
    # special files, skip
    [[ "$name" == '.' || "$name" == '..' || "$name" == '.DS_Store' ]] && continue

    path=`reduce_path $2/$name`
    # the file already exist
    if [[ -e $2/$name ]]; then
      # backup and overwrite only if the file content is different
      if [[ -n `diff "$f" "$2/$name"` ]]; then
        mv "$2/$name" "$backup"
        echo "backup then overwrite `blue $path`"
        cp -rp "$f" "$2"
      fi
    # the file does not already exist
    else
      echo "add `blue $path`"
      cp -rp "$f" "$2"
    fi
  done
}

#
# Check minimal Git. Abort script if not installed
#
check_minimal_git() {
  printf "check `blue git`..."
  # git not detected in the $PATH
  if [[ -z `type -p git` ]]; then
    # git also not installed inside /Developer
    if [[ ! -x /Developer/usr/bin/git ]]; then
      notok
      echo 'abort: Git must be installed'
      browser 'http://git-scm.com/download/mac'
      sleep 1
      terminal_frontmost
      exit 1
    fi
  fi
  ok
}

#
# Check Ruby. Abort script if not installed or try to upgrade if version < 1.9.3
#
check_ruby() {

  # inner functions
  function uninstall_rvm() {
    # the ~/.rvm directory must be 'sudo chown' to be deleted
    if [[ -d ~/.rvm ]]; then
      # prompt to chown /usr/local if I am not the owner
      check_chown -v ~/.rvm -R

      # abort after a new check
      [[ `check_owner ~/.rvm -R` -ne 1 ]] && echo "abort: you must be the owner of `red "~/.rvm"`" && exit 1

      rm -rf ~/.rvm
    fi

    rvm implode
    rm -rf ~/.rvmrc
    rm -rf /etc/rvmrc
    unset -f rvm

    # if uncommented line found in ~/.bash_profile to source rvm, comment it
    if [[ -f ~/.bash_profile && `egrep '^[^#].*\.rvm/scripts/rvm' ~/.bash_profile` ]]; then
      local tmp=`mktemp /tmp/rvm.XXXXX`
      sed '/^.*\.rvm\/scripts\/rvm.*/ s/^/#/' ~/.bash_profile > $tmp && mv $tmp ~/.bash_profile
      rm -f $tmp
    fi
  }
  function check_rbenv_ruby_build() {
    printf "check `blue rbenv`..."
    # rbenv not detected, install with homebrew
    if [[ -z `type -p rbenv` ]]; then
      notok
      message_delay "install `blue rbenv` with homebrew"
      brew install rbenv
    else
      ok
    fi

    printf "check `blue ruby-build`..."
    # ruby-build not detected, install with homebrew
    if [[ -z `type -p ruby-build` ]]; then
      notok
      message_delay "install `blue ruby-build` with homebrew"
      brew install ruby-build
    else
      ok
    fi

    # activate rbenv
    eval "$(rbenv init -)"
  }

  printf "check `blue ruby`..."
  # no ruby on the machine. Impossible on OS X, but just in case
  if [[ -z `type -p ruby` ]]; then
    notok
    echo 'abort: Ruby must be installed. Version 1.9.3 minimum'
    exit 1
  # ruby detected
  else
    # the version installed is lower than 1.9.3
    if [[ `ruby -e "puts RUBY_VERSION >= '1.9.3'"` == 'false' ]]; then
      notok
      # type -p rvm &>/dev/null
      # rvm detected, prompt to abort the script or uninstall it
      if [[ -n `type -p rvm` ]]; then
        echo "`red rvm` detected while `blue rbenv` is prefered"
        echo "please choose between:"
        echo " ➜ abort this script to install ruby manually with rvm"
        echo " ➜ uninstall rvm then install rbenv"
        while true; do
          echo -e -n "abort or uninstall? [Au]: "
          read r
          r=$(echo "$r" | tr '[A-Z]' '[a-z]')
          case "$r" in
            a|u) break ;;
             '') r='a' && break ;;
          esac
        done
        if [[ "$r" == 'a' ]]; then
          echo 'abort: Manual install chosen'
          exit 1
        else
          uninstall_rvm
        fi
      fi

      check_rbenv_ruby_build

      # install ruby 1.9.3
      message_delay "install `blue "ruby 1.9.3-p327"` with rbenv"
      rbenv install 1.9.3-p327
      rbenv global 1.9.3-p327

      # check ruby 1.9.3 intall, only valid in this install session
      printf "check `blue ruby`..."
      if [[ `ruby -e "puts RUBY_VERSION >= '1.9.3'"` == 'false' ]]; then
        notok
        echo "abort: the `red "scripted install of Ruby has failed"`. Please do it manually"
        exit 1
      fi
      ok
    # ruby 1.9.3 or higher detected
    else
      ok
    fi
  fi
  unset -f uninstall_rvm
  unset -f check_rbenv_ruby_build
}

#
# Update existing ~/.dotfiles repositoy or clone it first the first time
#
check_repository() {
  if test -e ~/.dotfiles; then
    local cwd="$(pwd)"
    echo -n "update `blue "~/.dotfiles"` repository..."
    cd ~/.dotfiles
    # capture error in temp file
    local tmp=`mktemp /tmp/git.XXXXX`
    git pull --quiet 2>$tmp
    if [[ $? -ne 0 ]]; then
      notok
      # echo error and delete temp file
      cat $tmp
      rm -f $tmp
      echo 'abort: Error with git pull'
      exit 1
    fi
    ok
    cd "$cwd"
  else
    echo -n "install `blue "~/.dotfiles"` repository..."
    # capture error in temp file
    local tmp=`mktemp /tmp/git.XXXXX`
    git clone --quiet https://github.com/jeromedecoster/dotfiles.git ~/.dotfiles 2>$tmp
    if [[ $? -ne 0 ]]; then
      notok
      # echo error and delete temp file
      cat $tmp
      rm -f $tmp
      echo 'abort: Error with git clone'
      exit 1
    fi
    rm -f $tmp
    ok
  fi
}

#
# Update existing Phantomjs or prompt to install it. Skip automatically after 7 seconds
#
check_phantomjs() {

  # inner functions
  function url() {
    local formula=`curl -s https://raw.github.com/mxcl/homebrew/master/Library/Formula/phantomjs.rb`
    echo "$formula" \
      | egrep ^[[:space:]]+url \
      | sed 's/^.*http/http/' \
      | sed 's/zip.*$/zip/'
  }
  function online_version() {
    echo `url | sed 's/^.*phantomjs-//' | sed 's/-.*$//'`
  }
  function install() {
    local tmp=`mktemp -d /tmp/phantomjs.XXXXX`
    curl -s -o $tmp/tmp.zip `url`
    unzip -q $tmp/tmp.zip "*bin/phantomjs" -d $tmp
    local src=`find $tmp -type f -name "*phantomjs"`
    cp $src ~/.dotfiles/osx/bin/
    rm -rf $tmp
    local version=`phantomjs --version`
    echo "installed `blue "phantomjs $version"`"
  }

  echo -n "check `blue phantomjs`..."
  # not installed
  if [ -z `type -p phantomjs` ]; then
    notok
    while true; do
      echo -n "install `blue phantomjs`? [yN]: "
      read -t 7 r
      # timeout return exitcode 1
      [[ $? -eq 1 ]] && echo 'n' && r='n' && break
      r=$(echo "$r" | tr '[A-Z]' '[a-z]')
      case "$r" in
        y|n) break ;;
         '') r='n' && break ;;
      esac
    done
    [[ "$r" == 'y' ]] && install || true

  # already installed
  else
    local online=`online_version`
    if [[ $online != `phantomjs --version` ]]; then
      notok
      echo "update `blue phantomjs` to $online"
      install
    else
      ok
    fi
  fi
  unset -f url
  unset -f online_version
  unset -f install
}


#
# Create backup folder and define the variable $backup if needed
#
create_backup() {
  if [[ -z $backup ]]; then
    # create backup folder
    backup=~/.dotfiles/.backup/$(date +%Y-%m-%d--%H-%M-%S)
    mkdir -p "$backup"
  fi
}

#
# Copy some dotfiles from ~/.dotfiles/osx/user to ~ and backup already existing files
#
install_user_files() {
  copy_files ~/.dotfiles/osx/user ~
}

#
# Install some chrome extensions. Prompt to skip the install. Skip automatically after 7 seconds
# The installation process is manual (open the extension page on the chrome web store)
# even if an automatic/silent process is possible and successfully tested
# Why? Because:
# - a locally installed crx will not benefit easily/automatically of the future updates
# - if you manually uninstall an extension that had been installed silently, this extension is definitly blacklisted
# http://developer.chrome.com/extensions/external_extensions.html#faq
#
chrome_extensions() {
  # abort function if chrome is not installed
  [[ ! -d '/Applications/Google Chrome.app' ]] && return

  # inner function
  function install() {
    local name=`blue "$1"`
    echo -n -e "check $name chrome extension..."
    if [[ ! -d ~/Library/Application\ Support/Google/Chrome/Default/Extensions/$2 ]]; then
      notok
      while true; do
        echo -e -n "install $name? [Yn]: "
        read r
        r=$(echo "$r" | tr '[A-Z]' '[a-z]')
        case "$r" in
          y|n) break ;;
           '') r='y' && break ;;
        esac
      done

      [[ "$r" == 'y' ]] && browser $3 && terminal_frontmost
    else
      ok
    fi
  }

  while true; do
    echo -n "install `blue "chrome extensions"`? [yN]: "
    read -t 7 r
    # timeout return exitcode 1
    [[ $? -eq 1 ]] && echo 'n' && r='n' && break
    r=$(echo "$r" | tr '[A-Z]' '[a-z]')
    case "$r" in
      y|n) break ;;
       '') r='n' && break ;;
    esac
  done
  if [[ "$r" == 'y' ]]; then
    install 'Adblock Plus' \
            'cfhdojbkjhnklbpkdaibdccddilifddb' \
            'https://chrome.google.com/webstore/detail/empty-title/cfhdojbkjhnklbpkdaibdccddilifddb'

    install 'PrettyPrint' \
            'nipdlgebaanapcphbcidpmmmkcecpkhg' \
            'https://chrome.google.com/webstore/detail/prettyprint/nipdlgebaanapcphbcidpmmmkcecpkhg'

    install 'JSON Formatter' \
            'bcjindcccaagfpapjjmafapmmgkkhgoa' \
            'https://chrome.google.com/webstore/detail/json-formatter/bcjindcccaagfpapjjmafapmmgkkhgoa'

    install 'LiveReload' \
            'jnihajbhpnppcggbcgedagnkighmdlei' \
            'https://chrome.google.com/webstore/detail/livereload/jnihajbhpnppcggbcgedagnkighmdlei'
  fi

  unset -f install
}

#
# Install some firefox extensions. Prompt to skip the install. Skip automatically after 7 seconds
# The installation process is manual, just like for the chrome process
#
firefox_extensions() {
  # abort function if firefox is not installed
  [[ ! -d '/Applications/Firefox.app' ]] && return

  # inner function
  function install() {
    local name=`blue "$1"`
    echo -n -e "check $name firefox extension..."
    local profile="$(find ~/Library/Application\ Support/Firefox/Profiles -type d -depth 1 -name '*.default')"
    if [[ ! "$profile" || ! -f "$profile/extensions/$2" ]]; then
      notok
      while true; do
        echo -e -n "install $name? [Yn]: "
        read r
        r=$(echo "$r" | tr '[A-Z]' '[a-z]')
        case "$r" in
          y|n) break ;;
           '') r='y' && break ;;
        esac
      done

      [[ "$r" == 'y' ]] && open -a Firefox.app $3 && terminal_frontmost
    else
      ok
    fi
  }

  while true; do
    echo -n "install `blue "firefox extensions"`? [yN]: "
    read -t 7 r
    # timeout return exitcode 1
    [[ $? -eq 1 ]] && echo 'n' && r='n' && break
    r=$(echo "$r" | tr '[A-Z]' '[a-z]')
    case "$r" in
      y|n) break ;;
       '') r='n' && break ;;
    esac
  done
  if [[ "$r" == 'y' ]]; then
    install 'Adblock Plus' \
            '{d10d0bf8-f5b5-c8b4-a8b2-2b9879e08c5d}.xpi' \
            'https://addons.mozilla.org/en-US/firefox/addon/adblock-plus/'

    install 'Firebug' \
            'firebug@software.joehewitt.com.xpi' \
            'https://addons.mozilla.org/en-US/firefox/addon/firebug/'

    # the next extensions require to restart firefox
    install 'Net Export' \
            'netexport@getfirebug.com.xpi' \
            'https://getfirebug.com/releases/netexport/'

    install 'DownThemAll' \
            '{DDC359D1-844A-42a7-9AA1-88A850A938A8}.xpi' \
            'https://addons.mozilla.org/en-US/firefox/addon/downthemall/'

    install 'LiveReload' \
            'livereload@livereload.com.xpi' \
            'http://help.livereload.com/kb/general-use/browser-extensions'
  fi

  unset -f install
}

#
# Check user permissions on /usr/local/lib/dtrace
# If this directory is not owned by you, nodejs fire some annoying 'permissions denied'
#
check_dtrace() {
  echo -n "check `blue /usr/local/lib/dtrace` permissions..."
  # the folder does not exist, simply create it
  if [[ ! -d /usr/local/lib/dtrace ]]; then
    mkdir -p /usr/local/lib/dtrace
    ok
  else
    # if we are not the owner of this folder, prompt to chown it
    if [[ `stat -f %u /usr/local/lib/dtrace` != `id -u` ]]; then
      notok
      echo "you are not the owner of the directory `blue /usr/local/lib/dtrace`"
      echo "this may result some annoying `red 'permissions denied'` problems with nodejs"
      while true; do
        echo -n "do you want to `blue 'sudo chown'` this directory? [Yn]: "
        read r
        r=$(echo "$r" | tr '[A-Z]' '[a-z]')
        case "$r" in
          y|n) break ;;
           '') r='y' && break ;;
        esac
      done
      [[ "$r" == 'y' ]] && sudo chown `whoami` /usr/local/lib/dtrace || true
    else
      ok
    fi
  fi
}

#
# Removes some backup directories if stayed empty
#
clear_backup() {
  if [[ -n $backup && `empty_directory $backup` ]]; then
    reduced=`reduce_path "$backup"`
    echo "delete empty directory `blue "$reduced"`"
    rm -d $backup
  fi
  if [[ `empty_directory ~/.dotfiles/.backup` ]]; then
    echo "delete empty directory `blue "~/.dotfiles/.backup"`"
    rm -d ~/.dotfiles/.backup
  fi
}


check_git() {
  echo -n "check `blue "homebrew git"`..."
  if [[ -z `brew ls | grep ^git$` ]]; then
    notok
    message_delay "install `blue git` with homebrew"
    brew install git
  else
    ok
    echo "upgrade `blue "homebrew git"`"
    brew upgrade git &>/dev/null
  fi
}

check_rvm() {

  # inner function
  function uninstall() {
    # the ~/.rvm directory must be 'sudo chown' to be deleted
    if [[ -d ~/.rvm ]]; then
      # prompt to chown /usr/local if I am not the owner
      check_chown -v ~/.rvm -R

      # abort after a new check
      [[ `check_owner ~/.rvm -R` -ne 1 ]] && echo "abort: you must be the owner of `red "~/.rvm"`" && exit 1

      rm -rf ~/.rvm
    fi

    rvm implode
    rm -rf ~/.rvmrc
    rm -rf /etc/rvmrc
    unset -f rvm

    # if uncommented line found in ~/.bash_profile to source rvm, comment it
    if [[ -f ~/.bash_profile && `egrep '^[^#].*\.rvm/scripts/rvm' ~/.bash_profile` ]]; then
      local tmp=`mktemp /tmp/rvm.XXXXX`
      sed '/^.*\.rvm\/scripts\/rvm.*/ s/^/#/' ~/.bash_profile > $tmp && mv $tmp ~/.bash_profile
      rm -f $tmp
    fi
  }

  echo -n "check `blue rvm`..."
  # rvm detected, prompt to abort the script or uninstall it
  if [[ -n `type -p rvm` ]]; then
    notok
    echo "`red rvm` detected while `blue rbenv` is prefered"
    echo "please choose between:"
    echo " ➜ uninstall `red rvm` then install `blue rbenv`"
    echo " ➜ abort this script"
    while true; do
      echo -e -n "uninstall or abort? [aU]: "
      read r
      r=$(echo "$r" | tr '[A-Z]' '[a-z]')
      case "$r" in
        a|u) break ;;
         '') r='u' && break ;;
      esac
    done
    if [[ "$r" == 'a' ]]; then
      echo 'abort: Script aborted by user'
      exit 1
    else
      uninstall
    fi
  else
    ok
  fi
}

check_rbenv() {
  echo -n "check `blue "homebrew rbenv"`..."
  if [[ -z `brew ls | grep ^rbenv$` ]]; then
    notok
    message_delay "install `blue rbenv` with homebrew"
    brew install rbenv
  else
    ok
    echo "upgrade `blue "homebrew rbenv"`"
    brew upgrade rbenv &>/dev/null
  fi
}

check_ruby_build() {
  echo -n "check `blue "homebrew ruby-build"`..."
  if [[ -z `brew ls | grep ^ruby-build$` ]]; then
    notok
    message_delay "install `blue ruby-build` with homebrew"
    brew install ruby-build
  else
    ok
    echo "upgrade `blue "homebrew ruby-build"`"
    brew upgrade ruby-build &>/dev/null
  fi
}

# function check_rbenv_ruby_build() {
#     printf "check `blue rbenv`..."
#     # rbenv not detected, install with homebrew
#     if [[ -z `type -p rbenv` ]]; then
#       notok
#       message_delay "install `blue rbenv` with homebrew"
#       brew install rbenv
#     else
#       ok
#     fi

#     printf "check `blue ruby-build`..."
#     # ruby-build not detected, install with homebrew
#     if [[ -z `type -p ruby-build` ]]; then
#       notok
#       message_delay "install `blue ruby-build` with homebrew"
#       brew install ruby-build
#     else
#       ok
#     fi

#     # activate rbenv
#     eval "$(rbenv init -)"
#   }

path_local_first
check_minimal_git
check_homebrew
check_git

check_rvm
check_rbenv
check_ruby_build

# echo $PATH


# check_ruby
# check_chown 'owner' ~/.rvm -R "this may result some annoying `red 'permissions denied'` problems with nodejs"
# check_chown '' ~/.rvm
# check_chown -v ~/.rvm
# check_chown -v ~/.rvm -R
# check_chown -v ~/.rvm -R
# check_chown -v ~/.rvm
# check_owner ~/.rvm
# check_owner ~/.rvm2 -R
# check_owner ~/.rvm/yo -R
# check_owner ~/.rvm/yo
# check_owner ~/.rvm/yo
# check_owner ~/.dotfiles -R
echo "yeah baby"
exit
check_repository
check_phantomjs
install_user_files
chrome_extensions
firefox_extensions
check_dtrace
clear_backup
