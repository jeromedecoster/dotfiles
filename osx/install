#!/bin/bash
[[ ! "$OSTYPE" =~ ^darwin ]] && echo "Aborted: this install script is only for OS X" && exit 1

#
# Write colored output
#
green() {
  echo -e "\033[0;32m$1\033[0m"
}
red() {
  echo -e "\033[0;31m$1\033[0m"
}
blue() {
  echo -e "\033[0;34m$1\033[0m"
}
ok() {
  echo `green OK`
}
notok() {
  echo `red KO`
}

#
# Try to reduce the path from /Users/username/.dotfiles to ~/.dotfiles
#
reduce_path() {
  # if the path is in the user directory ($HOME), reduce it using the shortcut '~'
  if [[ $HOME == ${1:0:${#HOME}} ]]; then
    echo ~${1:${#HOME}}
  # otherwise return the argument
  else
    echo $1
  fi
}

#
# Check if a directory is empty, the test includes the hidden files. Return 1 if empty, otherwise return nothing
#
empty_directory() {
  [[ `find $1 -depth 1 2>/dev/null | grep . -c` -eq 0 ]] && echo 1
}

#
# Open an url with chrome if installed, otherwise with firefox, otherwise with safari
#
browser() {
  local url=$1
  [[ ${url:0:4} != 'http' ]] && url="http://$url"

  # if Chrome, browse with it
  if [[ -d '/Applications/Google Chrome.app' ]]; then
    local cmd
    arch -i386 pwd &>/dev/null
    [[ $? -eq 0 ]] && cmd="arch -i386 osascript" || cmd="osascript"
    eval "$cmd" <<EOF
      set launched to true
      if application "Google Chrome" is not running then
        set launched to false
        tell application "Google Chrome" to activate
        delay 0.5
      end if
      on curtab(pUrl)
        tell application "Google Chrome" to set URL of active tab of front window to pUrl
      end curtab
      tell application "Google Chrome"
        if launched is false then
          curtab("$url") of me
        else
          if (count of properties of windows) is 0 then
            make new window
            curtab("$url") of me
          else
            if URL of active tab of front window is "chrome://newtab/" then
              curtab("$url") of me
            else
              tell front window to make new tab
              curtab("$url") of me
            end if
          end if
        end if
      end tell
EOF
  # if Firefox, browse with it
  elif [[ -d '/Applications/Firefox.app' ]]; then
    open -a Firefox.app $url
  # otherwise fallback to Safari
  elif [[ -d '/Applications/Safari.app' ]]; then
    open -a Safari.app $url
  fi
}

#
# Sets the frontmost opened terminal window as the foreground window on screen
# and sets the other terminal windows to the background. It's a dirty hack because
# activate set all the windows of an application to the foreground
#
terminal_frontmost() {
  local cmd
  arch -i386 pwd &>/dev/null
  [[ $? -eq 0 ]] && cmd="arch -i386 osascript" || cmd="osascript"
  eval "$cmd" <<EOF
  tell application "Terminal"
    activate
    set skip to true
    repeat with e in windows
      try
        if not skip then
          set frontmost of e to false
        end if
        set skip to false
      end try
    end repeat
    log ""
  end tell
EOF
}

#
# Copy files from a folder to another folder and automatically backup all already existing files
# The function invokes 'create_backup' who creates backup folder and defines the variable $backup
#
copy_files() {
  # some security tests before copy
  [[ $# -ne 2 ]] && echo `red 'runtime: copy_files require 2 arguments'` && exit 1
  [[ ! -d "$1" || ! -d "$2" ]] && echo `red 'runtime: copy_files require 2 valid paths'` && exit 1

  # create backup folder and define $backup
  create_backup

  local name path
  for f in $1/{.*,*}; do
    name=`basename "$f"`
    # not readable, skip
    [[ ! -r "$f" ]] && continue
    # special files, skip
    [[ "$name" == '.' || "$name" == '..' || "$name" == '.DS_Store' ]] && continue

    path=`reduce_path $2/$name`
    # the file already exist
    if [[ -e $2/$name ]]; then
      # backup and overwrite only if the file content is different
      if [[ -n `diff "$f" "$2/$name"` ]]; then
        mv "$2/$name" "$backup"
        echo "backup then overwrite `blue $path`"
        cp -rp "$f" "$2"
      fi
    # the file does not already exist
    else
      echo "add `blue $path`"
      cp -rp "$f" "$2"
    fi
  done
}

#
# Check Git. Abort script if not installed
#
check_git() {
  printf "check `blue git`..."
  if [[ -z `type -p git` ]]; then
    notok
    echo 'abort: Git must be installed'
    browser 'http://git-scm.com/download/mac'
    sleep 1
    terminal_frontmost
    exit 1
  fi
  ok
}

#
# Check Ruby. Abort script if not installed or version < 1.9.3
#
check_ruby() {
  printf "check `blue ruby`..."
  # if [[ -z `type -p ruby` || `ruby -e "puts RUBY_VERSION >= '1.9.3'"` == 'false' ]]; then
  #   notok
  #   echo 'Aborted: Ruby must be installed. Version 1.9.3 minimum'
  #   browser 'https://rvm.io/'
  #   sleep 1
  #   terminal_frontmost
  #   exit 1
  # fi

  # inner functions
  function uninstall_rvm() {
    # the ~/.rvm directory must be 'sudo chown' to be deleted
    if [[ -d ~/.rvm ]]; then
      while true; do
        echo -n "do you want to `blue 'sudo chown'` the directory `blue "~/.rvm"`? [Yn]: "
        read r
        r=$(echo "$r" | tr '[A-Z]' '[a-z]')
        case "$r" in
          y|n) break ;;
           '') r='y' && break ;;
        esac
      done
      [[ "$r" == 'y' ]] && sudo chown -R `whoami` ~/.rvm || true
    fi

    rvm implode
    rm -rf ~/.rvm
    rm -rf ~/.rvmrc
    rm -rf /etc/rvmrc
    unset -f rvm

    # if uncommented line found in ~/.bash_profile to source rvm, comment it
    if [[ -f ~/.bash_profile && `egrep '^[^#].*\.rvm/scripts/rvm' ~/.bash_profile` ]]; then
      local tmp=`mktemp /tmp/rvm.XXXXX`
      sed '/^.*\.rvm\/scripts\/rvm.*/ s/^/#/' ~/.bash_profile > $tmp && mv $tmp ~/.bash_profile
      rm -f $tmp
    fi
  }
  function install_rbenv_and_ruby() {
    echo "install_rbenv_and_ruby"
  }

  if [[ -z `type -p ruby` ]]; then
    notok
    echo 'abort: Ruby must be installed. Version 1.9.3 minimum'
    exit 1
  else
    if [[ `ruby -e "puts RUBY_VERSION >= '1.9.3'"` == 'false' ]]; then
      notok
      type -p rvm &>/dev/null
      # rvm detected, prompt to abort the script or uninstall it
      if [[ $? -eq 0 ]]; then
        echo "`red rvm` detected while `blue rbenv` is prefered"
        echo "please choose between:"
        echo " ➜ abort this script to install ruby manually with rvm"
        echo " ➜ uninstall rvm then install rbenv"
        while true; do
          echo -e -n "abort or uninstall? [Au]: "
          read r
          r=$(echo "$r" | tr '[A-Z]' '[a-z]')
          case "$r" in
            a|u) break ;;
             '') r='a' && break ;;
          esac
        done
        if [[ "$r" == 'a' ]]; then
          echo 'abort: Manual install chosen'
          exit 1
        else
          uninstall_rvm
        fi
      fi
      local version=`ruby -e "puts RUBY_VERSION"`
      type -p rbenv &>/dev/null
      # rbenv detected, abort with a message to upgrade Ruby
      if [[ $? -eq 0 ]]; then
        echo "abort: Ruby `red $version` detected. Version 1.9.3 minimum"
        echo "abort: please execute `blue "rbenv install 1.9.3-p327"`"
        exit 1
      else
        type -p brew &>/dev/null
        # homebrew detected, abort with a message to upgrade Ruby
        if [[ $? -eq 0 ]]; then
          echo "abort: Ruby `red $version` detected. Version 1.9.3 minimum"
          echo "abort: please execute `blue "brew install ruby"`"
          exit 1
        else
          install_rbenv_and_ruby
        fi
      fi
    else
      ok
    fi
  fi
  unset -f uninstall_rvm
  unset -f install_rbenv_and_ruby
}
check_ruby
exit

#
# Update existing ~/.dotfiles repositoy or clone it first the first time
#
check_repository() {
  if test -e ~/.dotfiles; then
    local cwd="$(pwd)"
    echo -n "update `blue "~/.dotfiles"` repository..."
    cd ~/.dotfiles
    # capture error in temp file
    local tmp=`mktemp /tmp/git.XXXXX`
    git pull --quiet 2>$tmp
    if [[ $? -ne 0 ]]; then
      notok
      # echo error and delete temp file
      cat $tmp
      rm -f $tmp
      echo 'abort: Error with git pull'
      exit 1
    fi
    ok
    cd "$cwd"
  else
    echo -n "install `blue "~/.dotfiles"` repository..."
    # capture error in temp file
    local tmp=`mktemp /tmp/git.XXXXX`
    git clone --quiet https://github.com/jeromedecoster/dotfiles.git ~/.dotfiles 2>$tmp
    if [[ $? -ne 0 ]]; then
      notok
      # echo error and delete temp file
      cat $tmp
      rm -f $tmp
      echo 'abort: Error with git clone'
      exit 1
    fi
    ok
  fi
}

#
# Update existing Phantomjs or prompt to install it. Skip automatically after 7 seconds
#
check_phantomjs() {
  echo -n "check `blue phantomjs`..."

  # inner functions
  function url() {
    local formula=`curl -s https://raw.github.com/mxcl/homebrew/master/Library/Formula/phantomjs.rb`
    echo "$formula" \
      | egrep ^[[:space:]]+url \
      | sed 's/^.*http/http/' \
      | sed 's/zip.*$/zip/'
  }
  function online_version() {
    echo `url | sed 's/^.*phantomjs-//' | sed 's/-.*$//'`
  }
  function install() {
    local tmp=`mktemp -d /tmp/phantomjs.XXXXX`
    curl -s -o $tmp/tmp.zip `url`
    unzip -q $tmp/tmp.zip "*bin/phantomjs" -d $tmp
    local src=`find $tmp -type f -name "*phantomjs"`
    cp $src ~/.dotfiles/osx/bin/
    rm -rf $tmp
    local version=`phantomjs --version`
    echo "installed `blue "phantomjs $version"`"
  }

  # not installed
  if [ -z `type -p phantomjs` ]; then
    notok
    while true; do
      echo -n "install `blue phantomjs`? [yN]: "
      read -t 7 r
      # timeout return exitcode 1
      [[ $? -eq 1 ]] && echo 'n' && r='n' && break
      r=$(echo "$r" | tr '[A-Z]' '[a-z]')
      case "$r" in
        y|n) break ;;
         '') r='n' && break ;;
      esac
    done
    [[ "$r" == 'y' ]] && install || true

  # already installed
  else
    local online=`online_version`
    if [[ $online != `phantomjs --version` ]]; then
      notok
      echo "update `blue phantomjs` to $online"
      install
    else
      ok
    fi
  fi
  unset -f url
  unset -f online_version
  unset -f install
}


#
# Create backup folder and define the variable $backup if needed
#
create_backup() {
  if [[ -z $backup ]]; then
    # create backup folder
    backup=~/.dotfiles/.backup/$(date +%Y-%m-%d--%H-%M-%S)
    mkdir -p "$backup"
  fi
}

#
# Copy some dotfiles from ~/.dotfiles/osx/user to ~ and backup already existing files
#
install_user_files() {
  copy_files ~/.dotfiles/osx/user ~
}

#
# Install some chrome extensions. Prompt to skip the install. Skip automatically after 7 seconds
# The installation process is manual (open the extension page on the chrome web store)
# even if an automatic/silent process is possible and successfully tested
# Why? Because:
# - a locally installed crx will not benefit easily/automatically of the future updates
# - if you manually uninstall an extension that had been installed silently, this extension is definitly blacklisted
# http://developer.chrome.com/extensions/external_extensions.html#faq
#
chrome_extensions() {
  # abort function if chrome is not installed
  [[ ! -d '/Applications/Google Chrome.app' ]] && return

  # inner function
  function install() {
    local name=`blue "$1"`
    echo -n -e "check $name chrome extension..."
    if [[ ! -d ~/Library/Application\ Support/Google/Chrome/Default/Extensions/$2 ]]; then
      notok
      while true; do
        echo -e -n "install $name? [Yn]: "
        read r
        r=$(echo "$r" | tr '[A-Z]' '[a-z]')
        case "$r" in
          y|n) break ;;
           '') r='y' && break ;;
        esac
      done

      [[ "$r" == 'y' ]] && browser $3 && terminal_frontmost
    else
      ok
    fi
  }

  while true; do
    echo -n "install `blue "chrome extensions"`? [yN]: "
    read -t 7 r
    # timeout return exitcode 1
    [[ $? -eq 1 ]] && echo 'n' && r='n' && break
    r=$(echo "$r" | tr '[A-Z]' '[a-z]')
    case "$r" in
      y|n) break ;;
       '') r='n' && break ;;
    esac
  done
  if [[ "$r" == 'y' ]]; then
    install 'Adblock Plus' \
            'cfhdojbkjhnklbpkdaibdccddilifddb' \
            'https://chrome.google.com/webstore/detail/empty-title/cfhdojbkjhnklbpkdaibdccddilifddb'

    install 'PrettyPrint' \
            'nipdlgebaanapcphbcidpmmmkcecpkhg' \
            'https://chrome.google.com/webstore/detail/prettyprint/nipdlgebaanapcphbcidpmmmkcecpkhg'

    install 'JSON Formatter' \
            'bcjindcccaagfpapjjmafapmmgkkhgoa' \
            'https://chrome.google.com/webstore/detail/json-formatter/bcjindcccaagfpapjjmafapmmgkkhgoa'

    install 'LiveReload' \
            'jnihajbhpnppcggbcgedagnkighmdlei' \
            'https://chrome.google.com/webstore/detail/livereload/jnihajbhpnppcggbcgedagnkighmdlei'
  fi

  unset -f install
}

#
# Install some firefox extensions. Prompt to skip the install. Skip automatically after 7 seconds
# The installation process is manual, just like for the chrome process
#
firefox_extensions() {
  # abort function if firefox is not installed
  [[ ! -d '/Applications/Firefox.app' ]] && return

  # inner function
  function install() {
    local name=`blue "$1"`
    echo -n -e "check $name firefox extension..."
    local profile="$(find ~/Library/Application\ Support/Firefox/Profiles -type d -depth 1 -name '*.default')"
    if [[ ! "$profile" || ! -f "$profile/extensions/$2" ]]; then
      notok
      while true; do
        echo -e -n "install $name? [Yn]: "
        read r
        r=$(echo "$r" | tr '[A-Z]' '[a-z]')
        case "$r" in
          y|n) break ;;
           '') r='y' && break ;;
        esac
      done

      [[ "$r" == 'y' ]] && open -a Firefox.app $3 && terminal_frontmost
    else
      ok
    fi
  }

  while true; do
    echo -n "install `blue "firefox extensions"`? [yN]: "
    read -t 7 r
    # timeout return exitcode 1
    [[ $? -eq 1 ]] && echo 'n' && r='n' && break
    r=$(echo "$r" | tr '[A-Z]' '[a-z]')
    case "$r" in
      y|n) break ;;
       '') r='n' && break ;;
    esac
  done
  if [[ "$r" == 'y' ]]; then
    install 'Adblock Plus' \
            '{d10d0bf8-f5b5-c8b4-a8b2-2b9879e08c5d}.xpi' \
            'https://addons.mozilla.org/en-US/firefox/addon/adblock-plus/'

    install 'Firebug' \
            'firebug@software.joehewitt.com.xpi' \
            'https://addons.mozilla.org/en-US/firefox/addon/firebug/'

    # the next extensions require to restart firefox
    install 'Net Export' \
            'netexport@getfirebug.com.xpi' \
            'https://getfirebug.com/releases/netexport/'

    install 'DownThemAll' \
            '{DDC359D1-844A-42a7-9AA1-88A850A938A8}.xpi' \
            'https://addons.mozilla.org/en-US/firefox/addon/downthemall/'

    install 'LiveReload' \
            'livereload@livereload.com.xpi' \
            'http://help.livereload.com/kb/general-use/browser-extensions'
  fi

  unset -f install
}

#
# Check user permissions on /usr/local/lib/dtrace
# If this directory is not owned by you, nodejs fire some annoying 'permissions denied'
#
check_dtrace() {
  echo -n "check `blue /usr/local/lib/dtrace` permissions..."
  # the folder does not exist, simply create it
  if [[ ! -d /usr/local/lib/dtrace ]]; then
    mkdir -p /usr/local/lib/dtrace
    ok
  else
    # if we are not the owner of this folder, prompt to chown it
    if [[ `stat -f %u /usr/local/lib/dtrace` != `id -u` ]]; then
      notok
      echo "you are not the owner of the directory `blue /usr/local/lib/dtrace`"
      echo "this may result some annoying `red 'permissions denied'` problems with nodejs"
      while true; do
        echo -n "do you want to `blue 'sudo chown'` this directory? [Yn]: "
        read r
        r=$(echo "$r" | tr '[A-Z]' '[a-z]')
        case "$r" in
          y|n) break ;;
           '') r='y' && break ;;
        esac
      done
      [[ "$r" == 'y' ]] && sudo chown `whoami` /usr/local/lib/dtrace || true
    else
      ok
    fi
  fi
}

#
# Removes some backup directories if stayed empty
#
clear_backup() {
  if [[ -n $backup && `empty_directory $backup` ]]; then
    reduced=`reduce_path "$backup"`
    echo "delete empty directory `blue "$reduced"`"
    rm -d $backup
  fi
  if [[ `empty_directory ~/.dotfiles/.backup` ]]; then
    echo "delete empty directory `blue "~/.dotfiles/.backup"`"
    rm -d ~/.dotfiles/.backup
  fi
}

check_git
check_ruby
check_repository
check_phantomjs
install_user_files
chrome_extensions
firefox_extensions
check_dtrace
clear_backup
