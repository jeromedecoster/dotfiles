#!/bin/bash
[[ ! "$OSTYPE" =~ ^darwin ]] && echo "Aborted: this install script is only for OS X" && exit 1

#
# Write colored output
#
green() {
  echo -e "\033[0;32m$1\033[0m"
}
red() {
  echo -e "\033[0;31m$1\033[0m"
}
blue() {
  # define $brightness if not already setted
  [[ -z "$brightness" ]] && brightness=`terminal_brightness`
  # for readability, echo in blue if the background is bright, otherwise in cyan
  [[ $brightness -gt 128 ]] && echo -e "\033[0;34m$1\033[0m" || echo -e "\033[0;36m$1\033[0m"
}
yellow() {
  echo -e "\033[0;33m$1\033[0m"
}
ok() {
  echo `green OK`
}
notok() {
  echo `red KO`
}

#
# Check the brightness of the terminal background
# Echo a value between 0 and 255
#
terminal_brightness() {
  local cmd
  arch -i386 pwd &>/dev/null
  [[ $? -eq 0 ]] && cmd="arch -i386 osascript" || cmd="osascript"
  if [[ $TERM_PROGRAM == 'iTerm.app' ]]; then
    eval "$cmd" <<EOF
  tell application "iTerm"
    tell the current terminal
      tell the current session
        set col to background color
        set r to (item 1 of col) / 257
        set g to (item 2 of col) / 257
        set b to (item 3 of col) / 257
        round (0.2126 * r) + (0.7152 * g) + (0.0722 * b)
      end tell
    end tell
  end tell
EOF
  # if it's not iTerm, it must be the classic Terminal, no other alternative
  else
    eval "$cmd" <<EOF
  tell application "Terminal"
    set col to background color of first window
    set r to (item 1 of col) / 257
    set g to (item 2 of col) / 257
    set b to (item 3 of col) / 257
    round (0.2126 * r) + (0.7152 * g) + (0.0722 * b)
  end tell
EOF
  fi
}

#
# Write a message with 5 seconds delay info
#
message_delay() {
  for i in {5..0}; do
    if [[ $i -gt 0 ]]; then
      echo "$1 `yellow "   [in $i sec]"`"
      sleep 1
      # erase_line
      printf "\033[1A\033[2K"
    else
      echo $1
    fi
  done
}

#
# Remove $1 from the $PATH
# It does not update the $PATH but just echo a ready to set one
#
path_remove() {
  # convert path to an array
  local tmp=$IFS
  IFS=:
  local t=($PATH)
  # remove paths found from the array
  unset IFS
  t=(${t[@]%%$1})
  # echo the result, an array joined with ':'
  IFS=:
  echo "${t[*]}"
  IFS=$tmp
}

#
# Echo the index of the first argument inside the $PATH
# Do nothing if not found
#
path_index() {
  # convert path to an array
  local tmp=$IFS
  IFS=:
  local t=($PATH)
  IFS=$tmp
  # loop and echo index if path found
  local i=0
  for p in ${t[@]}; do
    [[ $p = $1 ]] && echo $i && return
    i=$((i + 1))
  done
}

#
# Append the first argument to the $PATH
# Do nothing if not a valid directory or alreay in $PATH
#
path_append() {
  # security test before append
  [[ ! -d $1 ]] && return
  # not already in $PATH
  if [[ -z `path_index $1` ]]; then
    PATH=$1:$PATH
    export PATH
  fi
}

#
# Try to reduce the path from /Users/username/.dotfiles to ~/.dotfiles
# This is pure string operation, nothing to do with $PATH
#
reduce_path() {
  # if the path is in the user directory ($HOME), reduce it using the shortcut '~'
  if [[ $HOME == ${1:0:${#HOME}} ]]; then
    echo ~${1:${#HOME}}
  # otherwise return the argument
  else
    echo $1
  fi
}

#
# Check if I am the owner of a file or a directory
# The test can include all sub files and sub directories if the second argument is -R
# Return nothing if something failed
# Return 1 if I am the owner of file(s)/director(y|ies), otherwise return 0
#
check_owner() {
  # security test before check
  [[ -n $2 && $2 != '-R' ]] && echo `red 'runtime: check_owner wrong second argument'` && exit 1

  # abort if the target does not exist
  [[ ! -e "$1" ]] && return

  # recursive test
  if [[ $2 = '-R' ]]; then

    # abort if the target is not a directory
    [[ ! -d "$1" ]] && return

    local who=`whoami | xargs id -u`

    # return the count of files and directories from the directory "$1" where the owner is not me
    # the result include the "$1" directory
    # the result exclude some crap files and directories
    local count=`find -E "$1" ! -name .DS_Store \
                              ! -name desktop.ini \
                              ! -name Thumbs.db \
                              ! -regex ".*/\.DocumentRevisions-V100($|/.*)" \
                              ! -regex ".*/\.fseventsd($|/.*)" \
                              ! -regex ".*/\.Spotlight-V100($|/.*)" \
                              ! -regex ".*/\.TemporaryItems($|/.*)" \
                              ! -regex ".*/\.Trash($|/.*)" \
                              ! -regex ".*/\.Trashes($|/.*)" \
                              ! -regex ".*/\.(git|svn)($|/.*)" -exec stat -f %u '{}' \; -print \
                  | egrep "^[[:digit:]]+$" \
                  | grep -vc $who`

    [[ $count -eq 0 ]] && echo 1 || echo 0

  # not a recursive test
  else
    [[ `stat -f %u "$1"` = `id -u` ]] && echo 1 || echo 0
  fi
}

#
# Check if I am the owner of a file or a directory
# The test can also can include all sub files and sub directories if the third argument is -R
# If not, prompt to chown the file or directory
# All the content will be recursivly chowned if the third argument is -R
# Echo check and result if the first argument is -v
# The fourth argument is an additional echo
#
check_chown() {
  # some security tests before check
  [[ -n $1 && $1 != '-v' ]] && echo `red 'runtime: check_chown wrong first argument'` && exit 1
  [[ -n $3 && $3 != '-R' ]] && echo `red 'runtime: check_chown wrong third argument'` && exit 1

  local path=`reduce_path "$2"`

  # echo check if verbose mode
  [[ $1 = '-v' ]] && echo -n "check `blue "$path"` owner..."

  local check=`check_owner "$2" $3`
  # echo "check:$check:"
  # you are not the owner of file(s) or director(y|ies)
  if [[ -n $check && $check -eq 0 ]]; then

    # echo result if verbose mode
    [[ $1 = '-v' ]] && notok

    if [[ $3 = '-R' ]]; then
      echo "you are not the owner of the directory `blue "$path"` or all his content"
    else
      local kind='file'
      [[ -d "$2" ]] && kind='directory'
      echo "you are not the owner of the $word `blue "$path"`"
    fi

    [[ -n $4 ]] && echo "$4"

    while true; do
      echo -n "do you want to `blue 'sudo chown'` it? [Yn]: "
      read r
      r=$(echo "$r" | tr '[A-Z]' '[a-z]')
      case "$r" in
        y|n) break ;;
         '') r='y' && break ;;
      esac
    done
    [[ "$r" == 'y' ]] && sudo chown $3 `whoami` "$2"

  # you are he owner of file(s) or director(y|ies)
  # or the file or directory does not exist
  else
    # echo result if verbose mode
    [[ $1 = '-v' ]] && ok
  fi
}

#
# Dirty hack to disable homebrew warning 'It appears you have MacPorts or Fink installed'
# when you install or upgrade a formula
#
brew() {
  if [[ `type -P brew` ]]; then
    local path=`type -P brew`

    # if 'brew install' or 'brew upgrade' are invoked
    if [[ $1 == 'install' || $1 == 'upgrade' ]]; then
      local cwd="$(pwd)"
      local prefix=`eval "$path --prefix"`
      local file=`echo $prefix/Library/Homebrew/cmd/install.rb`

      # if uncommented line found in Homebrew/cmd/install.rb to check macports, comment it
      if [[ -f $file && `egrep '^[[:blank:]]+check_macports$' $file` ]]; then
        local tmp=`mktemp /tmp/homebrew.XXXXX`
        sed -E '/^[[:blank:]]+check_macports$/ s/^/#/' $file > $tmp && mv $tmp $file
        rm -f $tmp

        # execute brew
        eval "$path $@"

        # then revert the commented file
        cd "$prefix"
        git checkout $file
        cd "$cwd"
      # fallback, but normally you should never go here
      else
        eval "$path $@"
      fi
    # other commands
    else
      eval "$path $@"
    fi
  else
    `echo 'brew: command not found' >&2; exit 127`
  fi
}

#
# Check if a directory is empty, the test includes the hidden files. Return 1 if empty, otherwise return nothing
#
empty_directory() {
  [[ `find $1 -depth 1 2>/dev/null | grep . -c` -eq 0 ]] && echo 1
}

#
# Open an url with chrome if installed, otherwise with firefox, otherwise with safari
#
browser() {
  local url=$1
  [[ ${url:0:4} != 'http' ]] && url="http://$url"

  # if Chrome, browse with it
  if [[ -d '/Applications/Google Chrome.app' ]]; then
    local cmd
    arch -i386 pwd &>/dev/null
    [[ $? -eq 0 ]] && cmd="arch -i386 osascript" || cmd="osascript"
    eval "$cmd" <<EOF
      set launched to true
      if application "Google Chrome" is not running then
        set launched to false
        tell application "Google Chrome" to activate
        delay 0.5
      end if
      on curtab(pUrl)
        tell application "Google Chrome" to set URL of active tab of front window to pUrl
      end curtab
      tell application "Google Chrome"
        if launched is false then
          curtab("$url") of me
        else
          if (count of properties of windows) is 0 then
            make new window
            curtab("$url") of me
          else
            if URL of active tab of front window is "chrome://newtab/" then
              curtab("$url") of me
            else
              tell front window to make new tab
              curtab("$url") of me
            end if
          end if
        end if
      end tell
EOF
  # if Firefox, browse with it
  elif [[ -d '/Applications/Firefox.app' ]]; then
    open -a Firefox.app $url
  # otherwise fallback to Safari
  elif [[ -d '/Applications/Safari.app' ]]; then
    open -a Safari.app $url
  fi
}

#
# Sets the frontmost opened console window as the foreground window on screen
#
console_frontmost() {
  local cmd
  arch -i386 pwd &>/dev/null
  [[ $? -eq 0 ]] && cmd="arch -i386 osascript" || cmd="osascript"
  if [[ $TERM_PROGRAM == 'iTerm.app' ]]; then
    # sets iTerm as the foreground application on screen
    # no solution found to set only the frontmost window
    eval "$cmd" <<EOF
    tell application "iTerm"
      activate
    end tell
EOF
  elif [[ $TERM_PROGRAM == 'Apple_Terminal' ]]; then
    # sets the frontmost opened Terminal window as the foreground window on screen
    # and sets the other terminal windows to the background. It's a dirty hack because
    # activate set all the windows of an application to the foreground
    eval "$cmd" <<EOF
      tell application "Terminal"
        activate
        set skip to true
        repeat with e in windows
          try
            if not skip then
              set frontmost of e to false
            end if
            set skip to false
          end try
        end repeat
        log ""
      end tell
EOF
  fi
}

#
# Ring the bell 3 times
#
ring_bell() {
  for i in {1..3}; do
    echo -en "\007"
    sleep 0.2
  done
}

#
# Copy files from a folder to another folder and automatically backup all already existing files
# The function invokes 'create_backup' who creates backup folder and defines the variable $backup
#
copy_files() {
  # some security tests before copy
  [[ $# -ne 2 ]] && echo `red 'runtime: copy_files require 2 arguments'` && exit 1
  [[ ! -d "$1" || ! -d "$2" ]] && echo `red 'runtime: copy_files require 2 valid paths'` && exit 1

  # create backup folder and define $backup
  create_backup

  local name path
  for f in $1/{.*,*}; do
    name=`basename "$f"`
    # not readable, skip
    [[ ! -r "$f" ]] && continue
    # special files, skip
    [[ "$name" == '.' || "$name" == '..' || "$name" == '.DS_Store' ]] && continue

    path=`reduce_path $2/$name`
    # the file already exist
    if [[ -e $2/$name ]]; then
      # backup and overwrite only if the file content is different
      if [[ -n `diff "$f" "$2/$name"` ]]; then
        mv "$2/$name" "$backup"
        echo "backup then overwrite `blue $path`"
        cp -rp "$f" "$2"
      fi
    # the file does not already exist
    else
      echo "add `blue $path`"
      cp -rp "$f" "$2"
    fi
  done
}

#
# Create backup folder and define the variable $backup if needed
#
create_backup() {
  if [[ -z $backup ]]; then
    # create backup folder
    backup=~/.dotfiles/.backup/$(date +%Y-%m-%d--%H-%M-%S)
    mkdir -p "$backup"
  fi
}

#
# Check user permissions on /usr/local/lib/dtrace
# If this directory is not owned by you, nodejs fire some annoying 'permissions denied'
#
check_dtrace() {
  echo -n "check `blue /usr/local/lib/dtrace` permissions..."
  # the folder does not exist, simply create it
  if [[ ! -d /usr/local/lib/dtrace ]]; then
    mkdir -p /usr/local/lib/dtrace
    ok
  else
    # if we are not the owner of this folder, prompt to chown it
    if [[ `stat -f %u /usr/local/lib/dtrace` != `id -u` ]]; then
      notok
      echo "you are not the owner of the directory `blue /usr/local/lib/dtrace`"
      echo "this may result some annoying `red 'permissions denied'` problems with nodejs"
      while true; do
        echo -n "do you want to `blue 'sudo chown'` this directory? [Yn]: "
        read r
        r=$(echo "$r" | tr '[A-Z]' '[a-z]')
        case "$r" in
          y|n) break ;;
           '') r='y' && break ;;
        esac
      done
      [[ "$r" == 'y' ]] && sudo chown `whoami` /usr/local/lib/dtrace || true
    else
      ok
    fi
  fi
}

#
# Removes some backup directories if stayed empty
#
clear_backup() {
  if [[ -n $backup && `empty_directory $backup` ]]; then
    local reduced=`reduce_path "$backup"`
    echo "delete empty directory `blue "$reduced"`"
    rm -d $backup
  fi
  if [[ `empty_directory ~/.dotfiles/.backup` ]]; then
    echo "delete empty directory `blue "~/.dotfiles/.backup"`"
    rm -d ~/.dotfiles/.backup
  fi
}


#
# All install commands
#


#
# By default /usr/local/bin is placed after /usr/bin in the $PATH
# This function updates the $PATH with /usr/local/bin placed just before /usr/bin
# It's a temporary path, only valid in this install session
#
path_local_first() {
  local bin=`path_index /usr/bin`
  # /usr/bin is found before /usr/local/bin
  if [[ $bin -lt `path_index /usr/local/bin` ]]; then
    # remove /usr/local/bin from the path and convert path to an array
    local tmp=$IFS
    IFS=:
    local t=(`path_remove /usr/local/bin`)
    # replace in the array /usr/bin by /usr/local/bin:/usr/bin
    t[$bin]='/usr/local/bin:/usr/bin'
    # echo the result, an array joined with ':'
    IFS=:
    PATH=`echo "${t[*]}"`
    export PATH
    IFS=$tmp
  fi
}

#
# Check Git presence. Abort script if not installed
#
check_minimal_git() {
  printf "check `blue git`..."
  # git not detected in the $PATH
  if [[ -z `type -P git` ]]; then
    # git also not installed inside /Developer
    if [[ ! -x /Developer/usr/bin/git ]]; then
      notok
      echo 'abort: Git must be installed'
      browser 'http://git-scm.com/download/mac'
      sleep 1
      console_frontmost
      exit 1
    fi
  fi
  ok
}

#
# Check if homebrew is already installed. If yes, just update it
# If no, install a minimal version (without all git history) in /usr/local/homebrew
#
check_homebrew() {

  # inner functions
  function install() {
    # prompt to chown /usr/local if I am not the owner
    check_chown -v /usr/local

    # abort after a new check
    [[ `check_owner /usr/local` -ne 1 ]] && echo "abort: you must be the owner of `red /usr/local`" && exit 1

    message_delay "install minimal `blue homebrew` in `blue /usr/local/homebrew`"

    # clone homebrew with the available git
    local tmp
    [[ `type -P git` ]] && tmp=git || tmp=/Developer/usr/bin/git

    # install minimal homebrew (without all repository history)
    eval "$tmp clone --depth 1 https://github.com/mxcl/homebrew.git /usr/local/homebrew"

    if [[ $? -ne 0 ]]; then
      echo 'abort: Error with git clone'
      exit 1
    fi

    # temp path, only valid in this install session
    path_append /usr/local/homebrew/bin

    echo -n "check `blue homebrew` install..."
    # check if brew is now in the path
    if [[ -z `type -P brew` ]]; then
      notok
      echo "abort: the `red "scripted install of homebrew has failed"`. Please do it manually"
      exit 1
    else
      ok
    fi
  }
  function update() {
    echo -n "update `blue homebrew`..."
    # brew update: fetch the newest version of Homebrew and all formulae from GitHub using git
    local path=`type -P brew`
    # executes homebrew with full path to not call the workaround 'brew' function defined above
    eval "$path update 1>/dev/null"
    if [[ $? -ne 0 ]]; then
      notok
      echo "fail: `red "brew update"` return an error"
    else
      ok
    fi
  }

  echo -n "check `blue homebrew`..."
  # homebrew not detected, install it
  if [[ -z `type -P brew` ]]; then
    # brew not in the path and also not on the machine
    if [[ ! -x /usr/local/homebrew/bin/brew ]]; then
      notok
      install
    # it's only a path problem
    else
      path_append /usr/local/homebrew/bin
      ok
      update
    fi

  # homebrew detected, update the git source
  else
    ok
    update
  fi

  unset -f install
  unset -f update
}

#
# Check if command line tools are installed. It's required to compile homebrew formulas
# If no, abort the script
#
check_command_line_tools() {
  echo -n "check `blue 'command line tools'`..."
  local path=`type -P brew`
  local error=

  # homebrew detected
  if [[ -n "$path" && -x "$path" ]]; then
    path=`eval "$path --prefix"`/Library/Homebrew
    # dirty hack to call the command line tools detection done by homebrew
    local check=`ruby -e "$:.unshift('$path'); require 'global'; puts MacOS::CLT.installed?" 2>/dev/null`
    # $check is true, everything is ok
    if [[ -n `echo $check | grep 'true'` ]]; then
      ok
    # $check is false, command line tools are not installed
    elif [[ -n `echo $check | grep 'false'` ]]; then
      error="abort: the `red 'command line tools'` must be installed."
      error="$error Please do it manually `blue 'https://developer.apple.com/downloads/'`"
    # otherwise means the ruby call return an error
    # the detection done by homebrew must have changed. New method name?
    else
      error="fail: `red check_command_line_tools` return an error"
    fi
  # homebrew not detected, probably impossible here
  else
    error="fail: `red homebrew` not detected"
  fi

  if [[ -n "$error" ]]; then
    notok
    echo "$error"
    exit 1
  fi
}

#
# Check if $1 was installed with homebrew. If yes, just upgrade it
# If no, install $1 with homebrew
#
check_formula() {
  echo -n "check `blue "homebrew $1"`..."
  local tmp=(`brew ls -1`)
  for i in ${tmp[@]}; do
    [[ $i == $1 ]] && break
  done

  # $1 not found, install it
  if [[ $i != $1 ]]; then
    notok
    message_delay "install `blue $1` with homebrew"
    # warning: brew is a workaround function defined above
    brew install $1
  # $1 found, upgrade it
  else
    # upgrade only if the formula is outdated
    if [[ `brew outdated | egrep ^$1$` ]]; then
      notok
      echo "upgrade `blue "homebrew $1"`"
      # warning: brew is a workaround function defined above
      brew upgrade $1 &>/dev/null
    else
      ok
    fi
  fi
}

#
# Check if rvm is installed. If yes, prompt the user to uninstall it
# If the user chose to keep rvm, this script is aborted
#
check_rvm() {

  # inner function
  function uninstall() {
    # the ~/.rvm directory must be 'sudo chown' to be deleted
    if [[ -d ~/.rvm ]]; then
      # prompt to chown /usr/local if I am not the owner
      check_chown -v ~/.rvm -R

      # abort after a new check
      [[ `check_owner ~/.rvm -R` -ne 1 ]] && echo "abort: you must be the owner of `red "~/.rvm"`" && exit 1

      rm -rf ~/.rvm
    fi

    rvm implode
    rm -rf ~/.rvmrc
    rm -rf /etc/rvmrc
    unset -f rvm

    # if uncommented line found in ~/.bash_profile to source rvm, comment it
    if [[ -f ~/.bash_profile && `egrep '^[^#].*\.rvm/scripts/rvm' ~/.bash_profile` ]]; then
      local tmp=`mktemp /tmp/rvm.XXXXX`
      sed '/^.*\.rvm\/scripts\/rvm.*/ s/^/#/' ~/.bash_profile > $tmp && mv $tmp ~/.bash_profile
      rm -f $tmp
    fi
  }

  echo -n "check `blue rvm`..."
  # rvm detected, prompt to abort the script or uninstall it
  if [[ -n `type -p rvm` ]]; then
    notok
    echo "`red rvm` detected while `blue rbenv` is prefered"
    echo "please choose between:"
    echo " ➜ uninstall `red rvm` then install `blue rbenv`"
    echo " ➜ abort this script"
    while true; do
      echo -e -n "uninstall or abort? [aU]: "
      read r
      r=$(echo "$r" | tr '[A-Z]' '[a-z]')
      case "$r" in
        a|u) break ;;
         '') r='u' && break ;;
      esac
    done
    if [[ "$r" == 'a' ]]; then
      echo 'abort: Script aborted by user'
      exit 1
    else
      uninstall
    fi
  else
    ok
  fi

  unset -f uninstall
}

#
# Rbenv must be activated
#
activate_rbenv() {
  # rbenv executable found but _rbenv is not yet a function
  if [[ `type -P rbenv` && -z `type -t _rbenv` ]]; then
    # init rbenv
    echo "activate `blue rbenv`"
    eval "`rbenv init -`"
  fi
}

#
# Check if latest Ruby 1.9.3 and 2.0.0 patch version are installed with rbenv
# Install the missing versions then activates the newest version according to the previous version used
#
check_ruby() {

  # inner functions
  function latest() {
    echo `ruby-build --definitions | egrep "^$1-p[[:digit:]]+$" | tail -n 1`
  }
  function installed () {
    [[ -n `ls -1 ~/.rbenv/versions | egrep ^$1` ]] && echo 1
  }
  function activate() {
    echo "activate `blue "ruby $1"` with rbenv"
    rbenv global $v1 1>/dev/null
  }

  printf "check `blue "ruby 1.9.3"`..."
  local ver193=`latest 1.9.3`
  if [[ -z `installed $v193` ]]; then
    notok
    message_delay "install `blue "ruby $ver193"` with rbenv"
    rbenv install $ver193
    rbenv rehash
  else
    ok
  fi

  printf "check `blue "ruby 2.0.0"`..."
  local ver200=`latest 2.0.0`
  if [[ -z `installed $ver200` ]]; then
    notok
    message_delay "install `blue "ruby $ver200"` with rbenv"
    # compile ruby 2 works on Snow Leopard but fails on Mountain Lion
    # workaround: https://github.com/sstephenson/ruby-build/issues/377#issuecomment-23635029
    local path=`brew --prefix`/Cellar/openssl
    local directory=`ls -1 $path | egrep ^[[:digit:]] | sort -n -r | head -n 1`
    RUBY_CONFIGURE_OPTS=--with-openssl-dir=$path/$directory rbenv install $ver200
    rbenv rehash
  else
    ok
  fi

  # current ruby version is <= 1.9.3
  if [[ `ruby -e "puts RUBY_VERSION <= '1.9.3'"` == 'true' ]]; then
    activate $ver193
  # current ruby version is > 1.9.3
  else
    activate $ver200
  fi

  unset -f latest
  unset -f installed
  unset -f activate
}

#
# Update existing ~/.dotfiles repository or clone it for the first time
#
check_dotfiles() {

  # inner function
  function dotfiles_backup() {
    local name=.dotfiles-backup-`date +%Y-%m-%d--%H-%M-%S`
    mv ~/.dotfiles ~/$name &>/dev/null
    if [[ $? -ne 0 ]]; then
      echo "abort: Existing `red "~/.dotfiles"` can not be backuped"
      exit 1
    fi
    echo "backup `blue "~/.dotfiles"` as `blue "~/$name"`"
  }

  local cwd="$(pwd)"
  # if dotfiles directory already exists, checks his integrity
  if [[ -d ~/.dotfiles ]]; then
    cd ~/.dotfiles
    git status &>/dev/null
    # not a git repo
    if [[ $? -ne 0 ]]; then
      dotfiles_backup
    # a git repo
    else
      git remote -v | grep ^origin.*jeromedecoster/dotfiles.*fetch &>/dev/null
      # but not the same git repo
      [[ $? -ne 0 ]] && dotfiles_backup
    fi
  fi
  # if dotfiles directory already exists, revert locally modified files
  # it prevents the merge warnings with 'git pull'
  if [[ -d ~/.dotfiles ]]; then
    cd ~/.dotfiles
    local oIFS=$IFS
    IFS=$'\n'
    local files=(`git diff --name-status | grep "^M" | sed "s/^M[[:blank:]]//"`)
    IFS=$oIFS
    if [[ ${#files[@]} -ne 0 ]]; then
      # create backup folder and define $backup
      create_backup

      # backup files
      local name path
      for f in ${files[@]}; do
        name=${f##*/}
        path=${f:0:$((${#f} - ${#name}))}
        [[ -n $path ]] && mkdir -p "$backup/$path"
        mv ~/.dotfiles/$f "$backup/$path"
        path=`reduce_path "$backup/$path"`
        echo "backup `blue "~/.dotfiles/$f"` into `blue "$path"`"
      done
    fi
    # silently revert git repo, now ready to pull
    git reset --hard &>/dev/null
  fi
  cd "$cwd"

  # capture error in temp file
  local tmp=`mktemp /tmp/git.XXXXX`

  if [[ -d ~/.dotfiles ]]; then
    printf "update `blue "~/.dotfiles"` repository..."
    cd ~/.dotfiles
    # git pull with redirect error in the temp file
    git pull --quiet 2>$tmp
    if [[ $? -ne 0 ]]; then
      notok
      # echo error and delete temp file
      cat $tmp
      rm -f $tmp
      echo 'abort: Error with git pull'
      exit 1
    fi
    cd "$cwd"
  else
    printf "install `blue "~/.dotfiles"` repository..."
    # git clone with redirect error in the temp file
    git clone --quiet --depth 1 https://github.com/jeromedecoster/dotfiles.git ~/.dotfiles 2>$tmp
    if [[ $? -ne 0 ]]; then
      notok
      # echo error and delete temp file
      cat $tmp
      rm -f $tmp
      echo 'abort: Error with git clone'
      exit 1
    fi
  fi
  # delete temp file
  rm -f $tmp

  # if the file extras.sh does not exist, create it
  # this file is gitignored, it is used to add personal stuff that will be sourced when the terminal starts
  [[ ! -f ~/.dotfiles/osx/source/extras.sh ]] && touch ~/.dotfiles/osx/source/extras.sh
  ok

  unset -f dotfiles_backup
}

user_files() {

  # inner function
  function copy() {
    local name=`basename "$1"`
    # abort if not readable
    [[ ! -r "$1" ]] && return

    local path=`reduce_path $backup`

    # the file already exist
    if [[ -e ~/$name ]]; then
      if [[ -n `diff "$1" ~/$name` ]]; then
        echo "backup `blue "~/$name"` into `blue $path`"
        mv ~/$name "$backup"
        echo "overwrite `blue "~/$name"`"
        cp -rp "$1" ~/$name
      fi
    # the file does not already exist
    else
      echo "add `blue "~/$name"`"
      cp -rp "$1" ~/$name
    fi
  }
  function git_config() {
    git config --global $1 &>/dev/null
    if [[ $? -eq 1 ]]; then
      echo "set `blue "$1 $2"` into `blue "~/.gitconfig"`"
      git config --global $1 $2
    fi
  }
  function prompt_git_config() {
    git config --global $1 &>/dev/null
    if [[ $? -eq 1 ]]; then
      while true; do
        echo -e -n "define ~/.gitconfig `blue "$1"` : "
        read r
        case "$r" in
          '') ;;
           *) break ;;
        esac
      done
      echo "set `blue "$1 $r"` into `blue "~/.gitconfig"`"
      git config --global $1 "$r"
    fi
  }

  echo "install `blue "user dotfiles"` in `blue "~"`"
  # create backup folder and define $backup
  create_backup

  copy ~/.dotfiles/osx/user/.bash_profile
  copy ~/.dotfiles/osx/user/.bashrc
  copy ~/.dotfiles/osx/user/.inputrc

  # copy config files silently
  mkdir -p ~/.dotfiles/.cache/terminal
  cp ~/.dotfiles/osx/config/terminal/* ~/.dotfiles/.cache/terminal/

  if [[ `whoami` == `openssl enc -base64 -d <<< amVyb21lLmRlY29zdGVyCg==` ]]; then
    git_config user.name `openssl enc -base64 -d <<< amVyb21lQHdvcmsK`
    git_config user.email `openssl enc -base64 -d <<< Z2l0aHViQGplcm9tZWRlY29zdGVyLmNvbQo=`
  else
    prompt_git_config user.name
    prompt_git_config user.email
  fi

  git_config color.ui auto
  git_config color.status.untracked yellow

  unset -f copy
  unset -f git_config
  unset -f prompt_git_config
}

#
# Install some chrome extensions. Prompt to skip the install. Skip automatically after 7 seconds
# The installation process is manual (open the extension page on the chrome web store)
# even if an automatic/silent process is possible and successfully tested
# Why? Because:
# - a locally installed crx will not benefit easily/automatically of the future updates
# - if you manually uninstall an extension that had been installed silently, this extension is definitly blacklisted
# http://developer.chrome.com/extensions/external_extensions.html#faq
#
chrome_extensions() {
  # abort function if chrome is not installed
  [[ ! -d '/Applications/Google Chrome.app' ]] && return

  # inner functions
  function installed() {
    # check if the extensions $1 is installed
    # if the directory does not exists, the extension is not installed
    if [[ ! -d ~/Library/Application\ Support/Google/Chrome/Default/Extensions/$1 ]]; then
      # if the chrome install report exists
      if [[ -f ~/.dotfiles/.cache/extensions/chrome ]]; then
        # if the count of refused installations for the extension $1 is lower than 3 echo 0
        # means no, it is not installed
        if [[ `grep $1 ~/.dotfiles/.cache/extensions/chrome | cut -c 1` -lt 3 ]]; then
          echo 0
        # otherwise echo 2
        # means no, it is not installed, but it is skipped
        else
          echo 2
        fi
      # otherwise echo 0
      # means no, it is not installed
      else
        echo 0
      fi
    # the directory exists, echo 1
    # means yes, it is installed
    else
      echo 1
    fi
  }
  function update_report() {
    local file=~/.dotfiles/.cache/extensions/chrome
    # creates the file if needed
    [[ ! -f "$file" ]] && mkdir -p ~/.dotfiles/.cache/extensions && touch "$file"

    # the count of refused installations for this extension
    local count=`grep $1 "$file" | cut -c 1`
    if [[ -z "$count" ]]; then
      echo "1 $1" >> "$file"
    else
      count=$(($count + 1))
      local tmp=`mktemp /tmp/chrome.XXXXX`
      sed "s/.*$1$/$count $1/" "$file" > $tmp && mv $tmp "$file"
      rm -f $tmp
    fi
  }
  function install() {
    local name=`blue "$1"`
    echo -n -e "check $name chrome extension..."
    local status=`installed $2`
    if [[ $status -eq 0 ]]; then
      notok
      while true; do
        echo -e -n "install $name? [Yn]: "
        read r
        r=$(echo "$r" | tr '[A-Z]' '[a-z]')
        case "$r" in
          y|n) break ;;
           '') r='y' && break ;;
        esac
      done

      if [[ "$r" == 'y' ]]; then
        browser $3
        console_frontmost
      else
        update_report $2
      fi
    # the extension will not be installed
    else
      # echo OK or SKIP
      [[ $status -eq 1 ]] && ok || echo `green SKIP`
    fi
  }

  printf "check `blue "chrome extensions"`..."
  local all=
  while read id; do
    all="$all"`installed "$id"`
  done < <(cat <<EOF
cfhdojbkjhnklbpkdaibdccddilifddb
nipdlgebaanapcphbcidpmmmkcecpkhg
bcjindcccaagfpapjjmafapmmgkkhgoa
jnihajbhpnppcggbcgedagnkighmdlei
mlomiejdfkolichcflejclcbmpeaniij
EOF)

  # if $all contains at least one 0, means not installed
  if [[ `echo "$all" | grep -o "0" | wc -l` -gt 0 ]]; then
    notok
  else
    # if $all contains at least one 2, means skipped
    # otherwise means contains only 1, means all installed
    [[ `echo "$all" | grep -o "2" | wc -l` -gt 0 ]] && echo `green SKIP` || ok
    return
  fi

  echo "autoskip: You have `yellow "10 seconds"` to answer the following question"
  console_frontmost
  ring_bell

  while true; do
    echo -n "install `blue "chrome extensions"`? [yN]: "
    read -t 10 r
    # timeout return exitcode 1
    [[ $? -eq 1 ]] && echo 'n' && break
    r=$(echo "$r" | tr '[A-Z]' '[a-z]')
    case "$r" in
      y|n) break ;;
       '') r='n' && break ;;
    esac
  done
  if [[ "$r" == 'y' ]]; then
    install 'Adblock Plus' \
            cfhdojbkjhnklbpkdaibdccddilifddb \
            https://chrome.google.com/webstore/detail/empty-title/cfhdojbkjhnklbpkdaibdccddilifddb

    install PrettyPrint \
            nipdlgebaanapcphbcidpmmmkcecpkhg \
            https://chrome.google.com/webstore/detail/prettyprint/nipdlgebaanapcphbcidpmmmkcecpkhg

    install 'JSON Formatter' \
            bcjindcccaagfpapjjmafapmmgkkhgoa \
            https://chrome.google.com/webstore/detail/json-formatter/bcjindcccaagfpapjjmafapmmgkkhgoa

    install LiveReload \
            jnihajbhpnppcggbcgedagnkighmdlei \
            https://chrome.google.com/webstore/detail/livereload/jnihajbhpnppcggbcgedagnkighmdlei

    install Ghostery \
            mlomiejdfkolichcflejclcbmpeaniij \
            https://chrome.google.com/webstore/detail/ghostery/mlomiejdfkolichcflejclcbmpeaniij

  # not skipped, explicitly answered n
  elif [[ "$r" == 'n' ]]; then
    update_report cfhdojbkjhnklbpkdaibdccddilifddb
    update_report nipdlgebaanapcphbcidpmmmkcecpkhg
    update_report bcjindcccaagfpapjjmafapmmgkkhgoa
    update_report jnihajbhpnppcggbcgedagnkighmdlei
    update_report mlomiejdfkolichcflejclcbmpeaniij
  fi

  unset -f installed
  unset -f update_report
  unset -f install
}

#
# Install some firefox extensions. Prompt to skip the install. Skip automatically after 7 seconds
# The installation process is manual, just like for the chrome process
#
firefox_extensions() {
  # abort function if firefox is not installed
  [[ ! -d '/Applications/Firefox.app' ]] && return

  # inner functions
  function installed() {
    # check if the extensions $1 is installed
    local profile=`find ~/Library/Application\ Support/Firefox/Profiles -type d -depth 1 -name '*.default'`
    # if the file $profile/extensions/$e does not exists, the extension is not installed
    if [[ ! -f "$profile/extensions/$1" ]]; then
      # if the firefox install report exists
      if [[ -f ~/.dotfiles/.cache/extensions/firefox ]]; then
        # if the count of refused installations for the extension $1 is lower than 3 echo 0
        # means no, it is not installed
        if [[ `grep $1 ~/.dotfiles/.cache/extensions/firefox | cut -c 1` -lt 3 ]]; then
          echo 0
        # otherwise echo 2
        # means no, it is not installed, but it is skipped
        else
          echo 2
        fi
      # otherwise echo 0
      # means no, it is not installed
      else
        echo 0
      fi
    # the file exists, echo 1
    # means yes, it is installed
    else
      echo 1
    fi
  }
  function update_report() {
    local file=~/.dotfiles/.cache/extensions/firefox
    # creates the file if needed
    [[ ! -f "$file" ]] && mkdir -p ~/.dotfiles/.cache/extensions && touch "$file"

    # the count of refused installations for this extension
    local count=`grep $1 "$file" | cut -c 1`
    if [[ -z "$count" ]]; then
      echo "1 $1" >> "$file"
    else
      count=$(($count + 1))
      local tmp=`mktemp /tmp/firefox.XXXXX`
      sed "s/.*$1$/$count $1/" "$file" > $tmp && mv $tmp "$file"
      rm -f $tmp
    fi
  }
  function install() {
    local name=`blue "$1"`
    echo -n -e "check $name firefox extension..."
    local status=`installed $2`
    if [[ $status -eq 0 ]]; then
      notok
      while true; do
        echo -e -n "install $name? [Yn]: "
        read r
        r=$(echo "$r" | tr '[A-Z]' '[a-z]')
        case "$r" in
          y|n) break ;;
           '') r='y' && break ;;
        esac
      done

      if [[ "$r" == 'y' ]]; then
        open -a Firefox.app $3
        console_frontmost
      else
        update_report $2
      fi
    # the extension will not be installed
    else
      # echo OK or SKIP
      [[ $status -eq 1 ]] && ok || echo `green SKIP`
    fi
  }

  printf "check `blue "firefox extensions"`..."
  local all=
  while read xpi; do
    all="$all"`installed "$xpi"`
  done < <(cat <<EOF
{d10d0bf8-f5b5-c8b4-a8b2-2b9879e08c5d}.xpi
firebug@software.joehewitt.com.xpi
firefox@ghostery.com.xpi
netexport@getfirebug.com.xpi
{DDC359D1-844A-42a7-9AA1-88A850A938A8}.xpi
livereload@livereload.com.xpi
EOF)

  # if $all contains at least one 0, means not installed
  if [[ `echo "$all" | grep -o "0" | wc -l` -gt 0 ]]; then
    notok
  else
    # if $all contains at least one 2, means skipped
    # otherwise means contains only 1, means all installed
    [[ `echo "$all" | grep -o "2" | wc -l` -gt 0 ]] && echo `green SKIP` || ok
    return
  fi

  echo "autoskip: You have `yellow "10 seconds"` to answer the following question"
  console_frontmost
  ring_bell

  while true; do
    echo -n "install `blue "firefox extensions"`? [yN]: "
    read -t 10 r
    # timeout return exitcode 1
    [[ $? -eq 1 ]] && echo 'n' && r='n' && break
    r=$(echo "$r" | tr '[A-Z]' '[a-z]')
    case "$r" in
      y|n) break ;;
       '') r='n' && break ;;
    esac
  done
  if [[ "$r" == 'y' ]]; then
    install 'Adblock Plus' \
            {d10d0bf8-f5b5-c8b4-a8b2-2b9879e08c5d}.xpi \
            https://addons.mozilla.org/en-US/firefox/addon/adblock-plus/

    install Firebug \
            firebug@software.joehewitt.com.xpi \
            https://addons.mozilla.org/en-US/firefox/addon/firebug/

    install Ghostery \
            firefox@ghostery.com.xpi \
            https://addons.mozilla.org/fr/firefox/addon/ghostery/

    # the next extensions require to restart firefox
    install 'Net Export' \
            netexport@getfirebug.com.xpi \
            https://getfirebug.com/releases/netexport/

    install DownThemAll \
            {DDC359D1-844A-42a7-9AA1-88A850A938A8}.xpi \
            https://addons.mozilla.org/en-US/firefox/addon/downthemall/

    install LiveReload \
            livereload@livereload.com.xpi \
            http://help.livereload.com/kb/general-use/browser-extensions
  fi

  unset -f installed
  unset -f update_report
  unset -f install
}

#
# Install a precompiled imagemagick because homebrew require xquartz installed to compile it
# I do not want to install xquartz: https://xquartz.macosforge.org/landing/
# It is a bloated and opaque software. It also require a manual install/update
# Unfortunately, this is the opposite of what I want to facilitate the use of my dotfiles
# The compiled version comes from http://cactuslab.com/imagemagick/
#
check_imagemagick() {
  # inner function
  function install() {
    if [[ ! -d /opt/ImageMagick ]]; then
      while true; do
        echo -n "do you want to `blue 'sudo mkdir /opt/ImageMagick'`? [Yn]: "
        read r
        r=$(echo "$r" | tr '[A-Z]' '[a-z]')
        case "$r" in
          y|n) break ;;
           '') r='y' && break ;;
        esac
      done
      if [[ "$r" == 'y' ]]; then
        sudo mkdir -p /opt/ImageMagick
      else
        echo 'abort: Install aborted by user'
        return
      fi
    fi

    check_chown -v /opt/ImageMagick
    # you are still no the owner of the directory
    # means you reply 'n' to the previous command
    if [[ `check_owner /opt/ImageMagick` -eq 0 ]]; then
      echo 'abort: Install aborted by user'
      return
    fi

    local tmp=`mktemp -d /tmp/imagemagick.XXXXX`
    # download the version $1
    local url='https://github.com/jeromedecoster/executables/blob/master/osx'
    url="${url}/imagemagick/imagemagick-$1.tar.bz2?raw=master"
    echo "download and install `blue "imagemagick $1"`"
    curl -L -# -o $tmp/archive.tar.bz2 "$url"
    # extract in the temp directory
    tar -xjf $tmp/archive.tar.bz2 -C $tmp
    # then copy the content to not override the owner of /opt/ImageMagick
    cp -r $tmp/ImageMagick/* /opt/ImageMagick

    rm -rf $tmp
  }

  printf "check `blue imagemagick`..."
  local path=`which convert`
  # the newest version we can install, hosted in github.com/jeromedecoster/executables
  local version=6.8.6-3
  # imagemagick is not installed or not installed in /opt/ImageMagick
  if [[ -z `echo "$path" | grep "/opt/ImageMagick/bin/convert$"` ]]; then
    notok
    install $version
  else
    local current=`convert -h | head -n 1 | cut -f 3 -d ' '`
    # the installed version is older
    if [[ `ruby -e "puts '$version' > '$current'" | grep 'true'` ]]; then
      notok
      # uninstall
      [[ `check_owner /opt/ImageMagick` -eq 0 ]] && check_chown -v /opt/ImageMagick
      rm -rf /opt/ImageMagick/*
      # then install
      install $version
    else
      ok
    fi
  fi

  unset -f install
}

#
# Install a precompiled imagemagick because homebrew require xquartz installed to compile it
# See check_imagemagick comments
#
check_pngquant() {
  # inner function
  function install() {
    local tmp=`mktemp -d /tmp/pngquant.XXXXX`
    # download the version $1
    local url='https://github.com/jeromedecoster/executables/blob/master/osx'
    url="${url}/pngquant/pngquant-$1.tar.bz2?raw=master"
    echo "download and install `blue "pngquant $1"`"
    curl -L -# -o $tmp/archive.tar.bz2 "$url"
    # extract directly in the bin directory
    tar -xjf $tmp/archive.tar.bz2 -C ~/.dotfiles/osx/bin/

    rm -rf $tmp
  }

  printf "check `blue pngquant`..."
  local path=`which pngquant`
  # the newest version we can install, hosted in github.com/jeromedecoster/executables
  local version=2.0.0
  # pngquant is not installed or not installed within the dotfiles directory
  if [[ -z `echo "$path" | grep "osx/bin/pngquant$"` ]]; then
    notok
    install $version
  else
    local current=`pngquant -V | head -n 1 | cut -f 1 -d ' '`
    # the installed version is older
    if [[ `ruby -e "puts '$version' > '$current'" | grep 'true'` ]]; then
      notok
      # uninstall
      rm -f ~/.dotfiles/osx/bin/pngquant
      # then install
      install $version
    else
      ok
    fi
  fi

  unset -f install
}

#
# Homebrew install jpeg-turbo but does not link it, it is a keg-only formula
#
link_jpegturbo() {
  local version=`brew ls jpeg-turbo --versions | rev | cut -d ' ' -f 1 | rev`
  while read l; do
    printf "check `blue "$l link"`..."
    local link="`brew --prefix`/bin/$l"
    local target="`brew --prefix`/Cellar/jpeg-turbo/$version/bin/$l"
    # the link is already setted
    if [[ `readlink "$link" 2>/dev/null` == "$target" ]]; then
      ok
    else
      notok
      printf "link `blue "$l"`..."
      if [[ -x "$target" ]]; then
        ln -sf "$target" "$link"
        ok
      else
        notok
        echo "fail: `red "$target"` is not a valid target"
      fi
    fi
  done < <(cat <<EOF
cjpeg
djpeg
jpegtran
rdjpgcom
EOF)
}

path_local_first
check_minimal_git
check_homebrew
check_command_line_tools
check_formula git

check_rvm
check_formula rbenv
activate_rbenv
check_formula ruby-build
check_formula openssl
check_ruby

check_formula phantomjs
check_formula tree
check_formula man2html
check_formula coreutils
check_formula wdiff

check_dotfiles
user_files

chrome_extensions
firefox_extensions

check_imagemagick
check_pngquant
check_formula optipng
check_formula pngcrush
check_formula jpeg-turbo
link_jpegturbo

clear_backup

echo "yeah baby"
exit

check_dtrace
