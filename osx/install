#!/bin/bash
[[ ! "$OSTYPE" =~ ^darwin ]] && echo "Aborted: this install script is only for OS X" && exit 1

#
# Write colored output
#
green() {
  echo -e "\033[0;32m$1\033[0m"
}
red() {
  echo -e "\033[0;31m$1\033[0m"
}
blue() {
  echo -e "\033[0;34m$1\033[0m"
}
yellow() {
  echo -e "\033[0;33m$1\033[0m"
}
ok() {
  echo `green OK`
}
notok() {
  echo `red KO`
}

#
# Write a message with 5 seconds delay info
#
message_delay() {
  for i in {5..0}; do
    if [[ $i -gt 0 ]]; then
      echo "$1 `yellow "   [in $i sec]"`"
      sleep 1
      # erase_line
      printf "\033[1A\033[2K"
    else
      echo $1
    fi
  done
}

#
# Remove $1 from the $PATH
# It does not update the $PATH but just echo a ready to set one
#
path_remove() {
  # convert path to an array
  local tmp=$IFS
  IFS=:
  local t=($PATH)
  # remove paths found from the array
  unset IFS
  t=(${t[@]%%$1})
  # echo the result, an array joined with ':'
  IFS=:
  echo "${t[*]}"
  IFS=$tmp
}

#
# Echo the index of the first argument inside the $PATH
# Do nothing if not found
#
path_index() {
  # convert path to an array
  local tmp=$IFS
  IFS=:
  local t=($PATH)
  IFS=$tmp
  # loop and echo index if path found
  local i=0
  for p in ${t[@]}; do
    [[ $p = $1 ]] && echo $i && return
    i=$((i + 1))
  done
}

#
# Append the first argument to the $PATH
# Do nothing if not a valid directory or alreay in $PATH
#
path_append() {
  # security test before append
  [[ ! -d $1 ]] && return
  # not already in $PATH
  if [[ -z `path_index $1` ]]; then
    PATH=$1:$PATH
    export PATH
  fi
}

#
# Try to reduce the path from /Users/username/.dotfiles to ~/.dotfiles
# This is pure string operation, nothing to do with $PATH
#
reduce_path() {
  # if the path is in the user directory ($HOME), reduce it using the shortcut '~'
  if [[ $HOME == ${1:0:${#HOME}} ]]; then
    echo ~${1:${#HOME}}
  # otherwise return the argument
  else
    echo $1
  fi
}

#
# Check if I am the owner of a file or a directory
# The test can include all sub files and sub directories if the second argument is -R
# Return nothing if something failed
# Return 1 if I am the owner of file(s)/director(y|ies), otherwise return 0
#
check_owner() {
  # security test before check
  [[ -n $2 && $2 != '-R' ]] && echo `red 'runtime: check_owner wrong second argument'` && exit 1

  # abort if the target does not exist
  [[ ! -e "$1" ]] && return

  # recursive test
  if [[ $2 = '-R' ]]; then

    # abort if the target is not a directory
    [[ ! -d "$1" ]] && return

    local who=`whoami | xargs id -u`

    # return the count of files and directories from the directory "$1" where the owner is not me
    # the result include the "$1" directory
    # the result exclude some crap files and directories
    local count=`find -E "$1" ! -name .DS_Store \
                              ! -name desktop.ini \
                              ! -name Thumbs.db \
                              ! -regex ".*/\.DocumentRevisions-V100($|/.*)" \
                              ! -regex ".*/\.fseventsd($|/.*)" \
                              ! -regex ".*/\.Spotlight-V100($|/.*)" \
                              ! -regex ".*/\.TemporaryItems($|/.*)" \
                              ! -regex ".*/\.Trash($|/.*)" \
                              ! -regex ".*/\.Trashes($|/.*)" \
                              ! -regex ".*/\.(git|svn)($|/.*)" -exec stat -f %u '{}' \; -print \
                  | egrep "^[[:digit:]]+$" \
                  | grep -vc $who`

    [[ $count -eq 0 ]] && echo 1 || echo 0

  # not a recursive test
  else
    [[ `stat -f %u "$1"` = `id -u` ]] && echo 1 || echo 0
  fi
}

#
# Check if I am the owner of a file or a directory
# The test can also can include all sub files and sub directories if the third argument is -R
# If not, prompt to chown the file or directory
# All the content will be recursivly chowned if the third argument is -R
# Echo check and result if the first argument is -v
# The fourth argument is an additional echo
#
check_chown() {
  # some security tests before check
  [[ -n $1 && $1 != '-v' ]] && echo `red 'runtime: check_chown wrong first argument'` && exit 1
  [[ -n $3 && $3 != '-R' ]] && echo `red 'runtime: check_chown wrong third argument'` && exit 1

  local path=`reduce_path "$2"`

  # echo check if verbose mode
  [[ $1 = '-v' ]] && echo -n "check `blue "$path"` owner..."

  local check=`check_owner "$2" $3`
  # echo "check:$check:"
  # you are not the owner of file(s) or director(y|ies)
  if [[ -n $check && $check -eq 0 ]]; then

    # echo result if verbose mode
    [[ $1 = '-v' ]] && notok

    if [[ $3 = '-R' ]]; then
      echo "you are not the owner of the directory `blue "$path"` or all his content"
    else
      local kind='file'
      [[ -d "$2" ]] && kind='directory'
      echo "you are not the owner of the $word `blue "$path"`"
    fi

    [[ -n $4 ]] && echo "$4"

    while true; do
      echo -n "do you want to `blue 'sudo chown'` it? [Yn]: "
      read r
      r=$(echo "$r" | tr '[A-Z]' '[a-z]')
      case "$r" in
        y|n) break ;;
         '') r='y' && break ;;
      esac
    done
    [[ "$r" == 'y' ]] && sudo chown $3 `whoami` "$2"

  # you are he owner of file(s) or director(y|ies)
  # or the file or directory does not exist
  else
    # echo result if verbose mode
    [[ $1 = '-v' ]] && ok
  fi
}

#
# Dirty hack to disable homebrew warning 'It appears you have MacPorts or Fink installed'
# when you install or upgrade a formula
#
brew() {
  if [[ `type -P brew` ]]; then
    local path=`type -P brew`

    # if 'brew install' or 'brew upgrade' are invoked
    if [[ $1 == 'install' || $1 == 'upgrade' ]]; then
      local cwd="$(pwd)"
      local prefix=`eval "$path --prefix"`
      local file=`echo $prefix/Library/Homebrew/cmd/install.rb`

      # if uncommented line found in Homebrew/cmd/install.rb to check macports, comment it
      if [[ -f $file && `egrep '^[[:blank:]]+check_macports$' $file` ]]; then
        local tmp=`mktemp /tmp/homebrew.XXXXX`
        sed -E '/^[[:blank:]]+check_macports$/ s/^/#/' $file > $tmp && mv $tmp $file
        rm -f $tmp

        # execute brew
        eval "$path $@"

        # then revert the commented file
        cd "$prefix"
        git checkout $file
        cd "$cwd"
      # fallback, but normally you should never go here
      else
        eval "$path $@"
      fi
    # other commands
    else
      eval "$path $@"
    fi
  else
    `echo 'brew: command not found' >&2; exit 127`
  fi
}

#
# Check if a directory is empty, the test includes the hidden files. Return 1 if empty, otherwise return nothing
#
empty_directory() {
  [[ `find $1 -depth 1 2>/dev/null | grep . -c` -eq 0 ]] && echo 1
}

#
# Open an url with chrome if installed, otherwise with firefox, otherwise with safari
#
browser() {
  local url=$1
  [[ ${url:0:4} != 'http' ]] && url="http://$url"

  # if Chrome, browse with it
  if [[ -d '/Applications/Google Chrome.app' ]]; then
    local cmd
    arch -i386 pwd &>/dev/null
    [[ $? -eq 0 ]] && cmd="arch -i386 osascript" || cmd="osascript"
    eval "$cmd" <<EOF
      set launched to true
      if application "Google Chrome" is not running then
        set launched to false
        tell application "Google Chrome" to activate
        delay 0.5
      end if
      on curtab(pUrl)
        tell application "Google Chrome" to set URL of active tab of front window to pUrl
      end curtab
      tell application "Google Chrome"
        if launched is false then
          curtab("$url") of me
        else
          if (count of properties of windows) is 0 then
            make new window
            curtab("$url") of me
          else
            if URL of active tab of front window is "chrome://newtab/" then
              curtab("$url") of me
            else
              tell front window to make new tab
              curtab("$url") of me
            end if
          end if
        end if
      end tell
EOF
  # if Firefox, browse with it
  elif [[ -d '/Applications/Firefox.app' ]]; then
    open -a Firefox.app $url
  # otherwise fallback to Safari
  elif [[ -d '/Applications/Safari.app' ]]; then
    open -a Safari.app $url
  fi
}

#
# Sets the frontmost opened terminal window as the foreground window on screen
# and sets the other terminal windows to the background. It's a dirty hack because
# activate set all the windows of an application to the foreground
#
terminal_frontmost() {
  local cmd
  arch -i386 pwd &>/dev/null
  [[ $? -eq 0 ]] && cmd="arch -i386 osascript" || cmd="osascript"
  eval "$cmd" <<EOF
  tell application "Terminal"
    activate
    set skip to true
    repeat with e in windows
      try
        if not skip then
          set frontmost of e to false
        end if
        set skip to false
      end try
    end repeat
    log ""
  end tell
EOF
}

#
# Ring the bell 3 times
#
ring_bell() {
  for i in {1..3}; do
    echo -en "\007"
  done
}

#
# Copy files from a folder to another folder and automatically backup all already existing files
# The function invokes 'create_backup' who creates backup folder and defines the variable $backup
#
copy_files() {
  # some security tests before copy
  [[ $# -ne 2 ]] && echo `red 'runtime: copy_files require 2 arguments'` && exit 1
  [[ ! -d "$1" || ! -d "$2" ]] && echo `red 'runtime: copy_files require 2 valid paths'` && exit 1

  # create backup folder and define $backup
  create_backup

  local name path
  for f in $1/{.*,*}; do
    name=`basename "$f"`
    # not readable, skip
    [[ ! -r "$f" ]] && continue
    # special files, skip
    [[ "$name" == '.' || "$name" == '..' || "$name" == '.DS_Store' ]] && continue

    path=`reduce_path $2/$name`
    # the file already exist
    if [[ -e $2/$name ]]; then
      # backup and overwrite only if the file content is different
      if [[ -n `diff "$f" "$2/$name"` ]]; then
        mv "$2/$name" "$backup"
        echo "backup then overwrite `blue $path`"
        cp -rp "$f" "$2"
      fi
    # the file does not already exist
    else
      echo "add `blue $path`"
      cp -rp "$f" "$2"
    fi
  done
}

#
# Create backup folder and define the variable $backup if needed
#
create_backup() {
  if [[ -z $backup ]]; then
    # create backup folder
    backup=~/.dotfiles/.backup/$(date +%Y-%m-%d--%H-%M-%S)
    mkdir -p "$backup"
  fi
}

#
# Check user permissions on /usr/local/lib/dtrace
# If this directory is not owned by you, nodejs fire some annoying 'permissions denied'
#
check_dtrace() {
  echo -n "check `blue /usr/local/lib/dtrace` permissions..."
  # the folder does not exist, simply create it
  if [[ ! -d /usr/local/lib/dtrace ]]; then
    mkdir -p /usr/local/lib/dtrace
    ok
  else
    # if we are not the owner of this folder, prompt to chown it
    if [[ `stat -f %u /usr/local/lib/dtrace` != `id -u` ]]; then
      notok
      echo "you are not the owner of the directory `blue /usr/local/lib/dtrace`"
      echo "this may result some annoying `red 'permissions denied'` problems with nodejs"
      while true; do
        echo -n "do you want to `blue 'sudo chown'` this directory? [Yn]: "
        read r
        r=$(echo "$r" | tr '[A-Z]' '[a-z]')
        case "$r" in
          y|n) break ;;
           '') r='y' && break ;;
        esac
      done
      [[ "$r" == 'y' ]] && sudo chown `whoami` /usr/local/lib/dtrace || true
    else
      ok
    fi
  fi
}

#
# Removes some backup directories if stayed empty
#
clear_backup() {
  if [[ -n $backup && `empty_directory $backup` ]]; then
    local reduced=`reduce_path "$backup"`
    echo "delete empty directory `blue "$reduced"`"
    rm -d $backup
  fi
  if [[ `empty_directory ~/.dotfiles/.backup` ]]; then
    echo "delete empty directory `blue "~/.dotfiles/.backup"`"
    rm -d ~/.dotfiles/.backup
  fi
}


#
# All install commands
#


#
# By default /usr/local/bin is placed after /usr/bin in the $PATH
# This function updates the $PATH with /usr/local/bin placed just before /usr/bin
# It's a temporary path, only valid in this install session
#
path_local_first() {
  local bin=`path_index /usr/bin`
  # /usr/bin is found before /usr/local/bin
  if [[ $bin -lt `path_index /usr/local/bin` ]]; then
    # remove /usr/local/bin from the path and convert path to an array
    local tmp=$IFS
    IFS=:
    local t=(`path_remove /usr/local/bin`)
    # replace in the array /usr/bin by /usr/local/bin:/usr/bin
    t[$bin]='/usr/local/bin:/usr/bin'
    # echo the result, an array joined with ':'
    IFS=:
    PATH=`echo "${t[*]}"`
    export PATH
    IFS=$tmp
  fi
}

#
# Check Git presence. Abort script if not installed
#
check_minimal_git() {
  printf "check `blue git`..."
  # git not detected in the $PATH
  if [[ -z `type -P git` ]]; then
    # git also not installed inside /Developer
    if [[ ! -x /Developer/usr/bin/git ]]; then
      notok
      echo 'abort: Git must be installed'
      browser 'http://git-scm.com/download/mac'
      sleep 1
      terminal_frontmost
      exit 1
    fi
  fi
  ok
}

#
# Check if homebrew is already installed. If yes, just update it
# If no, install a minimal version (without all git history) in /usr/local/homebrew
#
check_homebrew() {

  # inner functions
  function install() {
    # prompt to chown /usr/local if I am not the owner
    check_chown -v /usr/local

    # abort after a new check
    [[ `check_owner /usr/local` -ne 1 ]] && echo "abort: you must be the owner of `red /usr/local`" && exit 1

    message_delay "install minimal `blue homebrew` in `blue /usr/local/homebrew`"

    # clone homebrew with the available git
    local tmp
    [[ `type -P git` ]] && tmp=git || tmp=/Developer/usr/bin/git

    # install minimal homebrew (without all repository history)
    eval "$tmp clone --depth 1 https://github.com/mxcl/homebrew.git /usr/local/homebrew"

    if [[ $? -ne 0 ]]; then
      echo 'abort: Error with git clone'
      exit 1
    fi

    # temp path, only valid in this install session
    path_append /usr/local/homebrew/bin

    echo -n "check `blue homebrew` install..."
    # check if brew is now in the path
    if [[ -z `type -P brew` ]]; then
      notok
      echo "abort: the `red "scripted install of homebrew has failed"`. Please do it manually"
      exit 1
    else
      ok
    fi
  }
  function update() {
    echo -n "update `blue homebrew`..."
    # brew update: fetch the newest version of Homebrew and all formulae from GitHub using git
    local path=`type -P brew`
    # executes homebrew with full path to not call the workaround 'brew' function defined above
    eval "$path update 1>/dev/null"
    if [[ $? -ne 0 ]]; then
      notok
      echo "fail: `red "brew update"` return an error"
    else
      ok
    fi
  }

  echo -n "check `blue homebrew`..."
  # homebrew not detected, install it
  if [[ -z `type -P brew` ]]; then
    # brew not in the path and also not on the machine
    if [[ ! -x /usr/local/homebrew/bin/brew ]]; then
      notok
      install
    # it's only a path problem
    else
      path_append /usr/local/homebrew/bin
      ok
      update
    fi

  # homebrew detected, update the git source
  else
    ok
    update
  fi

  unset -f install
  unset -f update
}

#
# Check if $1 was installed with homebrew. If yes, just upgrade it
# If no, install $1 with homebrew
#
check_formula() {
  echo -n "check `blue "homebrew $1"`..."
  local tmp=(`brew ls -1`)
  for i in ${tmp[@]}; do
    [[ $i == $1 ]] && break
  done

  # $1 not found, install it
  if [[ $i != $1 ]]; then
    notok
    message_delay "install `blue $1` with homebrew"
    # warning: brew is a workaround function defined above
    brew install $1
  # $1 found, upgrade it
  else
    # upgrade only if the formula is outdated
    if [[ `brew outdated | egrep ^$1$` ]]; then
      notok
      echo "upgrade `blue "homebrew $1"`"
      # warning: brew is a workaround function defined above
      brew upgrade $1 &>/dev/null
    else
      ok
    fi
  fi
}

#
# Check if rvm is installed. If yes, prompt the user to uninstall it
# If the user chose to keep rvm, this script is aborted
#
check_rvm() {

  # inner function
  function uninstall() {
    # the ~/.rvm directory must be 'sudo chown' to be deleted
    if [[ -d ~/.rvm ]]; then
      # prompt to chown /usr/local if I am not the owner
      check_chown -v ~/.rvm -R

      # abort after a new check
      [[ `check_owner ~/.rvm -R` -ne 1 ]] && echo "abort: you must be the owner of `red "~/.rvm"`" && exit 1

      rm -rf ~/.rvm
    fi

    rvm implode
    rm -rf ~/.rvmrc
    rm -rf /etc/rvmrc
    unset -f rvm

    # if uncommented line found in ~/.bash_profile to source rvm, comment it
    if [[ -f ~/.bash_profile && `egrep '^[^#].*\.rvm/scripts/rvm' ~/.bash_profile` ]]; then
      local tmp=`mktemp /tmp/rvm.XXXXX`
      sed '/^.*\.rvm\/scripts\/rvm.*/ s/^/#/' ~/.bash_profile > $tmp && mv $tmp ~/.bash_profile
      rm -f $tmp
    fi
  }

  echo -n "check `blue rvm`..."
  # rvm detected, prompt to abort the script or uninstall it
  if [[ -n `type -p rvm` ]]; then
    notok
    echo "`red rvm` detected while `blue rbenv` is prefered"
    echo "please choose between:"
    echo " ➜ uninstall `red rvm` then install `blue rbenv`"
    echo " ➜ abort this script"
    while true; do
      echo -e -n "uninstall or abort? [aU]: "
      read r
      r=$(echo "$r" | tr '[A-Z]' '[a-z]')
      case "$r" in
        a|u) break ;;
         '') r='u' && break ;;
      esac
    done
    if [[ "$r" == 'a' ]]; then
      echo 'abort: Script aborted by user'
      exit 1
    else
      uninstall
    fi
  else
    ok
  fi

  unset -f uninstall
}

#
# Rbenv must be activated
#
activate_rbenv() {
  # rbenv executable found but _rbenv is not yet a function
  if [[ `type -P rbenv` && -z `type -t _rbenv` ]]; then
    # init rbenv
    echo "activate `blue rbenv`"
    eval "`rbenv init -`"
  fi
}

#
# Check if latest Ruby 1.9.3 and 2.0.0 patch version are installed with rbenv
# Install the missing versions then activates the newest version according to the previous version used
#
check_ruby() {

  # inner functions
  function latest() {
    echo `ruby-build --definitions | egrep "^$1-p[[:digit:]]+$" | tail -n 1`
  }
  function installed () {
    [[ -n `ls -1 ~/.rbenv/versions | egrep ^$1` ]] && echo 1
  }
  function activate() {
    echo "activate `blue "ruby $1"` with rbenv"
    rbenv global $v1 1>/dev/null
  }

  printf "check `blue "ruby 1.9.3"`..."
  local ver193=`latest 1.9.3`
  if [[ -z `installed $v193` ]]; then
    notok
    message_delay "install `blue "ruby $ver193"` with rbenv"
    rbenv install $ver193
    rbenv rehash
  else
    ok
  fi

  printf "check `blue "ruby 2.0.0"`..."
  local ver200=`latest 2.0.0`
  if [[ -z `installed $ver200` ]]; then
    notok
    message_delay "install `blue "ruby $ver200"` with rbenv"
    # compile ruby 2 works on Snow Leopard but fails on Mountain Lion
    # workaround: https://github.com/sstephenson/ruby-build/issues/377#issuecomment-23635029
    local path=`brew --prefix`/Cellar/openssl
    local directory=`ls -1 $path | egrep ^[[:digit:]] | sort -n -r | head -n 1`
    RUBY_CONFIGURE_OPTS=--with-openssl-dir=$path/$directory rbenv install $ver200
    rbenv rehash
  else
    ok
  fi

  # current ruby version is <= 1.9.3
  if [[ `ruby -e "puts RUBY_VERSION <= '1.9.3'"` == 'true' ]]; then
    activate $ver193
  # current ruby version is > 1.9.3
  else
    activate $ver200
  fi

  unset -f latest
  unset -f installed
  unset -f activate
}

#
# Update existing ~/.dotfiles repository or clone it for the first time
#
check_dotfiles() {

  # inner function
  function dotfiles_backup() {
    local name=.dotfiles-backup-`date +%Y-%m-%d--%H-%M-%S`
    mv ~/.dotfiles ~/$name &>/dev/null
    if [[ $? -ne 0 ]]; then
      echo "abort: Existing `red "~/.dotfiles"` can not be backuped"
      exit 1
    fi
    echo "backup `blue "~/.dotfiles"` as `blue "~/$name"`"
  }

  local cwd="$(pwd)"
  # if dotfiles directory already exists, checks his integrity
  if [[ -d ~/.dotfiles ]]; then
    cd ~/.dotfiles
    git status &>/dev/null
    # not a git repo
    if [[ $? -ne 0 ]]; then
      dotfiles_backup
    # a git repo
    else
      git remote -v | grep ^origin.*jeromedecoster/dotfiles.*fetch &>/dev/null
      # but not the same git repo
      [[ $? -ne 0 ]] && dotfiles_backup
    fi
  fi
  # if dotfiles directory already exists, revert locally modified files
  # it prevents the merge warnings with 'git pull'
  if [[ -d ~/.dotfiles ]]; then
    cd ~/.dotfiles
    local oIFS=$IFS
    IFS=$'\n'
    local files=(`git diff --name-status | grep "^M" | sed "s/^M[[:blank:]]//"`)
    IFS=$oIFS
    if [[ ${#files[@]} -ne 0 ]]; then
      # create backup folder and define $backup
      create_backup

      # backup files
      local name path
      for f in ${files[@]}; do
        name=${f##*/}
        path=${f:0:$((${#f} - ${#name}))}
        [[ -n $path ]] && mkdir -p "$backup/$path"
        mv ~/.dotfiles/$f "$backup/$path"
        path=`reduce_path "$backup/$path"`
        echo "backup `blue "~/.dotfiles/$f"` into `blue "$path"`"
      done
    fi
    # silently revert git repo, now ready to pull
    git reset --hard &>/dev/null
  fi
  cd "$cwd"

  # capture error in temp file
  local tmp=`mktemp /tmp/git.XXXXX`

  if [[ -d ~/.dotfiles ]]; then
    printf "update `blue "~/.dotfiles"` repository..."
    cd ~/.dotfiles
    # git pull with redirect error in the temp file
    git pull --quiet 2>$tmp
    if [[ $? -ne 0 ]]; then
      notok
      # echo error and delete temp file
      cat $tmp
      rm -f $tmp
      echo 'abort: Error with git pull'
      exit 1
    fi
    cd "$cwd"
  else
    printf "install `blue "~/.dotfiles"` repository..."
    # git clone with redirect error in the temp file
    git clone --quiet https://github.com/jeromedecoster/dotfiles.git ~/.dotfiles 2>$tmp
    if [[ $? -ne 0 ]]; then
      notok
      # echo error and delete temp file
      cat $tmp
      rm -f $tmp
      echo 'abort: Error with git clone'
      exit 1
    fi
  fi
  # delete temp file
  rm -f $tmp

  # if the file extras.sh does not exist, create it
  # this file is gitignored, it is used to add personal stuff that will be sourced when the terminal starts
  [[ ! -f ~/.dotfiles/osx/source/extras.sh ]] && touch ~/.dotfiles/osx/source/extras.sh
  ok

  unset -f dotfiles_backup
}

user_files() {

  # inner function
  function copy() {
    local name=`basename "$1"`
    # abort if not readable
    [[ ! -r "$1" ]] && return

    local path=`reduce_path $backup`

    # the file already exist
    if [[ -e ~/$name ]]; then
      if [[ -n `diff "$1" ~/$name` ]]; then
        echo "backup `blue "~/$name"` into `blue $path`"
        mv ~/$name "$backup"
        echo "overwrite `blue "~/$name"`"
        cp -rp "$1" ~/$name
      fi
    # the file does not already exist
    else
      echo "add `blue "~/$name"`"
      cp -rp "$1" ~/$name
    fi
  }
  function git_config() {
    git config --global $1 &>/dev/null
    if [[ $? -eq 1 ]]; then
      echo "set `blue "$1 $2"` into `blue "~/.gitconfig"`"
      git config --global $1 $2
    fi
  }
  function prompt_git_config() {
    git config --global $1 &>/dev/null
    if [[ $? -eq 1 ]]; then
      while true; do
        echo -e -n "define ~/.gitconfig `blue "$1"` : "
        read r
        case "$r" in
          '') ;;
           *) break ;;
        esac
      done
      echo "set `blue "$1 $r"` into `blue "~/.gitconfig"`"
      git config --global $1 "$r"
    fi
  }

  echo "install `blue "user dotfiles"` in `blue "~"`"
  # create backup folder and define $backup
  create_backup

  copy ~/.dotfiles/osx/user/.bash_profile
  copy ~/.dotfiles/osx/user/.inputrc

  # copy config files silently
  mkdir -p ~/.dotfiles/.cache
  cp ~/.dotfiles/osx/config/terminal-bright-256.sh ~/.dotfiles/.cache
  cp ~/.dotfiles/osx/config/terminal-bright.sh ~/.dotfiles/.cache
  cp ~/.dotfiles/osx/config/terminal-dark-256.sh ~/.dotfiles/.cache
  cp ~/.dotfiles/osx/config/terminal-dark.sh ~/.dotfiles/.cache
  cp ~/.dotfiles/osx/config/terminal.sh ~/.dotfiles/.cache

  local h=hub a=@ o=ome c=com d=deco
  local s=ster g=git w=work j=jer
  if [[ `whoami` == "$j$o.$d$s" ]]; then
    git_config user.name "$j$o${a}$w"
    git_config user.email "$g$h$a$j$o$d$s.$c"
  else
    prompt_git_config user.name
    prompt_git_config user.email
  fi

  git_config color.ui auto
  git_config color.status.untracked yellow

  unset -f copy
  unset -f git_config
  unset -f prompt_git_config
}

#
# Install some chrome extensions. Prompt to skip the install. Skip automatically after 7 seconds
# The installation process is manual (open the extension page on the chrome web store)
# even if an automatic/silent process is possible and successfully tested
# Why? Because:
# - a locally installed crx will not benefit easily/automatically of the future updates
# - if you manually uninstall an extension that had been installed silently, this extension is definitly blacklisted
# http://developer.chrome.com/extensions/external_extensions.html#faq
#
chrome_extensions() {
  # abort function if chrome is not installed
  [[ ! -d '/Applications/Google Chrome.app' ]] && return

  # inner functions
  function installed() {
    # for all extensions id given as argument
    for e in $@; do
      # the first non installed extension abort the function, nothing is returned
      [[ ! -d ~/Library/Application\ Support/Google/Chrome/Default/Extensions/$e ]] && return
    done
    # otherwise return something
    echo 1
  }
  function install() {
    local name=`blue "$1"`
    echo -n -e "check $name chrome extension..."
    if [[ -z `installed $2` ]]; then
      notok
      while true; do
        echo -e -n "install $name? [Yn]: "
        read r
        r=$(echo "$r" | tr '[A-Z]' '[a-z]')
        case "$r" in
          y|n) break ;;
           '') r='y' && break ;;
        esac
      done

      [[ "$r" == 'y' ]] && browser $3 && terminal_frontmost
    else
      ok
    fi
  }

  printf "check `blue "chrome extensions"`..."
  [[ -n `installed cfhdojbkjhnklbpkdaibdccddilifddb \
                   nipdlgebaanapcphbcidpmmmkcecpkhg \
                   bcjindcccaagfpapjjmafapmmgkkhgoa \
                   jnihajbhpnppcggbcgedagnkighmdlei` ]] && ok && return
  notok

  echo "autoskip: You have `yellow "10 seconds"` to answer the following question"
  terminal_frontmost
  ring_bell

  while true; do
    echo -n "install `blue "chrome extensions"`? [yN]: "
    read -t 10 r
    # timeout return exitcode 1
    [[ $? -eq 1 ]] && echo 'n' && r='n' && break
    r=$(echo "$r" | tr '[A-Z]' '[a-z]')
    case "$r" in
      y|n) break ;;
       '') r='n' && break ;;
    esac
  done
  if [[ "$r" == 'y' ]]; then
    install 'Adblock Plus' \
            cfhdojbkjhnklbpkdaibdccddilifddb \
            https://chrome.google.com/webstore/detail/empty-title/cfhdojbkjhnklbpkdaibdccddilifddb

    install PrettyPrint \
            nipdlgebaanapcphbcidpmmmkcecpkhg \
            https://chrome.google.com/webstore/detail/prettyprint/nipdlgebaanapcphbcidpmmmkcecpkhg

    install 'JSON Formatter' \
            bcjindcccaagfpapjjmafapmmgkkhgoa \
            https://chrome.google.com/webstore/detail/json-formatter/bcjindcccaagfpapjjmafapmmgkkhgoa

    install LiveReload \
            jnihajbhpnppcggbcgedagnkighmdlei \
            https://chrome.google.com/webstore/detail/livereload/jnihajbhpnppcggbcgedagnkighmdlei
  fi

  unset -f installed
  unset -f install
}

#
# Install some firefox extensions. Prompt to skip the install. Skip automatically after 7 seconds
# The installation process is manual, just like for the chrome process
#
firefox_extensions() {
  # abort function if firefox is not installed
  [[ ! -d '/Applications/Firefox.app' ]] && return

  # inner functions
  function installed() {
    local profile
    # for all extensions id given as argument
    for e in $@; do
      # the first non installed extension abort the function, nothing is returned
      profile="$(find ~/Library/Application\ Support/Firefox/Profiles -type d -depth 1 -name '*.default')"
      [[ ! "$profile" || ! -f "$profile/extensions/$e" ]] && return
    done
    # otherwise return something
    echo 1
  }
  function install() {
    local name=`blue "$1"`
    echo -n -e "check $name firefox extension..."
    if [[ -z `installed $2` ]]; then
      notok
      while true; do
        echo -e -n "install $name? [Yn]: "
        read r
        r=$(echo "$r" | tr '[A-Z]' '[a-z]')
        case "$r" in
          y|n) break ;;
           '') r='y' && break ;;
        esac
      done

      [[ "$r" == 'y' ]] && open -a Firefox.app $3 && terminal_frontmost
    else
      ok
    fi
  }

  printf "check `blue "firefox extensions"`..."
  [[ -n `installed {d10d0bf8-f5b5-c8b4-a8b2-2b9879e08c5d}.xpi \
                   firebug@software.joehewitt.com.xpi \
                   netexport@getfirebug.com.xpi \
                   {DDC359D1-844A-42a7-9AA1-88A850A938A8}.xpi \
                   livereload@livereload.com.xpi \
                   firebug@software.joehewitt.com.xpi` ]] && ok && return
  notok

  echo "autoskip: You have `yellow "10 seconds"` to answer the following question"
  terminal_frontmost
  ring_bell

  while true; do
    echo -n "install `blue "firefox extensions"`? [yN]: "
    read -t 10 r
    # timeout return exitcode 1
    [[ $? -eq 1 ]] && echo 'n' && r='n' && break
    r=$(echo "$r" | tr '[A-Z]' '[a-z]')
    case "$r" in
      y|n) break ;;
       '') r='n' && break ;;
    esac
  done
  if [[ "$r" == 'y' ]]; then
    install 'Adblock Plus' \
            {d10d0bf8-f5b5-c8b4-a8b2-2b9879e08c5d}.xpi \
            https://addons.mozilla.org/en-US/firefox/addon/adblock-plus/

    install Firebug \
            firebug@software.joehewitt.com.xpi \
            https://addons.mozilla.org/en-US/firefox/addon/firebug/

    # the next extensions require to restart firefox
    install 'Net Export' \
            netexport@getfirebug.com.xpi \
            https://getfirebug.com/releases/netexport/

    install DownThemAll \
            {DDC359D1-844A-42a7-9AA1-88A850A938A8}.xpi \
            https://addons.mozilla.org/en-US/firefox/addon/downthemall/

    install LiveReload \
            livereload@livereload.com.xpi \
            http://help.livereload.com/kb/general-use/browser-extensions
  fi

  unset -f installed
  unset -f install
}


path_local_first
check_minimal_git
check_homebrew
check_formula git

check_rvm
check_formula rbenv
activate_rbenv
check_formula ruby-build
check_formula openssl
check_ruby

check_formula phantomjs
check_formula tree
check_formula man2html
check_formula coreutils

check_dotfiles
user_files

chrome_extensions
firefox_extensions

echo "yeah baby"
exit

check_dtrace
clear_backup
